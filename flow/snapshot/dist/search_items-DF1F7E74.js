searchNodes=[{"doc":"","ref":"Astarte.Flow.Auth.html","title":"Astarte.Flow.Auth","type":"module"},{"doc":"","ref":"Astarte.Flow.Auth.html#fetch_public_key/1","title":"Astarte.Flow.Auth.fetch_public_key/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.AstartePublicKeyProvider.html","title":"Astarte.Flow.Auth.AstartePublicKeyProvider","type":"module"},{"doc":"","ref":"Astarte.Flow.Auth.FilesystemPublicKeyProvider.html","title":"Astarte.Flow.Auth.FilesystemPublicKeyProvider","type":"module"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.html","title":"Astarte.Flow.Auth.Guardian","type":"module"},{"doc":"Callback implementation for Guardian.after_encode_and_sign/4 .","ref":"Astarte.Flow.Auth.Guardian.html#after_encode_and_sign/4","title":"Astarte.Flow.Auth.Guardian.after_encode_and_sign/4","type":"function"},{"doc":"Callback implementation for Guardian.after_sign_in/5 .","ref":"Astarte.Flow.Auth.Guardian.html#after_sign_in/5","title":"Astarte.Flow.Auth.Guardian.after_sign_in/5","type":"function"},{"doc":"Callback implementation for Guardian.before_sign_out/3 .","ref":"Astarte.Flow.Auth.Guardian.html#before_sign_out/3","title":"Astarte.Flow.Auth.Guardian.before_sign_out/3","type":"function"},{"doc":"Callback implementation for Guardian.build_claims/3 .","ref":"Astarte.Flow.Auth.Guardian.html#build_claims/3","title":"Astarte.Flow.Auth.Guardian.build_claims/3","type":"function"},{"doc":"Fetches the configuration for this module","ref":"Astarte.Flow.Auth.Guardian.html#config/0","title":"Astarte.Flow.Auth.Guardian.config/0","type":"function"},{"doc":"Returns a resolved value of the configuration found at a key. See Guardian.Config.resolve_value/1 .","ref":"Astarte.Flow.Auth.Guardian.html#config/2","title":"Astarte.Flow.Auth.Guardian.config/2","type":"function"},{"doc":"Decodes and verifies a token using the configuration on the implementation module. See Guardian.decode_and_verify/4","ref":"Astarte.Flow.Auth.Guardian.html#decode_and_verify/3","title":"Astarte.Flow.Auth.Guardian.decode_and_verify/3","type":"function"},{"doc":"The default type of token for this module","ref":"Astarte.Flow.Auth.Guardian.html#default_token_type/0","title":"Astarte.Flow.Auth.Guardian.default_token_type/0","type":"function"},{"doc":"Encodes the claims. See Guardian.encode_and_sign/4 for more information","ref":"Astarte.Flow.Auth.Guardian.html#encode_and_sign/3","title":"Astarte.Flow.Auth.Guardian.encode_and_sign/3","type":"function"},{"doc":"Exchanges a token of one type for another. See Guardian.exchange for more information","ref":"Astarte.Flow.Auth.Guardian.html#exchange/4","title":"Astarte.Flow.Auth.Guardian.exchange/4","type":"function"},{"doc":"Callback implementation for Guardian.on_exchange/3 .","ref":"Astarte.Flow.Auth.Guardian.html#on_exchange/3","title":"Astarte.Flow.Auth.Guardian.on_exchange/3","type":"function"},{"doc":"Callback implementation for Guardian.on_refresh/3 .","ref":"Astarte.Flow.Auth.Guardian.html#on_refresh/3","title":"Astarte.Flow.Auth.Guardian.on_refresh/3","type":"function"},{"doc":"Callback implementation for Guardian.on_revoke/3 .","ref":"Astarte.Flow.Auth.Guardian.html#on_revoke/3","title":"Astarte.Flow.Auth.Guardian.on_revoke/3","type":"function"},{"doc":"Callback implementation for Guardian.on_verify/3 .","ref":"Astarte.Flow.Auth.Guardian.html#on_verify/3","title":"Astarte.Flow.Auth.Guardian.on_verify/3","type":"function"},{"doc":"Provides the content of the token but without verification of either the claims or the signature. Claims will be present at the :claims key. See Guardian.peek/2 for more information","ref":"Astarte.Flow.Auth.Guardian.html#peek/1","title":"Astarte.Flow.Auth.Guardian.peek/1","type":"function"},{"doc":"Refresh a token. See Guardian.refresh for more information","ref":"Astarte.Flow.Auth.Guardian.html#refresh/2","title":"Astarte.Flow.Auth.Guardian.refresh/2","type":"function"},{"doc":"Callback implementation for Guardian.resource_from_claims/1 .","ref":"Astarte.Flow.Auth.Guardian.html#resource_from_claims/1","title":"Astarte.Flow.Auth.Guardian.resource_from_claims/1","type":"function"},{"doc":"Fetch the resource and claims directly from a token See Guardian.resource_from_token for more information","ref":"Astarte.Flow.Auth.Guardian.html#resource_from_token/3","title":"Astarte.Flow.Auth.Guardian.resource_from_token/3","type":"function"},{"doc":"Revoke a token. See Guardian.revoke for more information","ref":"Astarte.Flow.Auth.Guardian.html#revoke/2","title":"Astarte.Flow.Auth.Guardian.revoke/2","type":"function"},{"doc":"If Guardian.Plug.SlidingCookie is used, this callback will be invoked to return the new claims, or an error (which will mean the cookie will not be refreshed).","ref":"Astarte.Flow.Auth.Guardian.html#sliding_cookie/3","title":"Astarte.Flow.Auth.Guardian.sliding_cookie/3","type":"function"},{"doc":"Callback implementation for Guardian.subject_for_token/2 .","ref":"Astarte.Flow.Auth.Guardian.html#subject_for_token/2","title":"Astarte.Flow.Auth.Guardian.subject_for_token/2","type":"function"},{"doc":"Callback implementation for Guardian.verify_claims/2 .","ref":"Astarte.Flow.Auth.Guardian.html#verify_claims/2","title":"Astarte.Flow.Auth.Guardian.verify_claims/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html","title":"Astarte.Flow.Auth.Guardian.Plug","type":"module"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#authenticated?/2","title":"Astarte.Flow.Auth.Guardian.Plug.authenticated?/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#clear_remember_me/2","title":"Astarte.Flow.Auth.Guardian.Plug.clear_remember_me/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#current_claims/2","title":"Astarte.Flow.Auth.Guardian.Plug.current_claims/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#current_resource/2","title":"Astarte.Flow.Auth.Guardian.Plug.current_resource/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#current_token/2","title":"Astarte.Flow.Auth.Guardian.Plug.current_token/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#implementation/0","title":"Astarte.Flow.Auth.Guardian.Plug.implementation/0","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#put_current_claims/3","title":"Astarte.Flow.Auth.Guardian.Plug.put_current_claims/3","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#put_current_resource/3","title":"Astarte.Flow.Auth.Guardian.Plug.put_current_resource/3","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#put_current_token/3","title":"Astarte.Flow.Auth.Guardian.Plug.put_current_token/3","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#put_session_token/3","title":"Astarte.Flow.Auth.Guardian.Plug.put_session_token/3","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#remember_me/4","title":"Astarte.Flow.Auth.Guardian.Plug.remember_me/4","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#remember_me_from_token/4","title":"Astarte.Flow.Auth.Guardian.Plug.remember_me_from_token/4","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#sign_in/4","title":"Astarte.Flow.Auth.Guardian.Plug.sign_in/4","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.Guardian.Plug.html#sign_out/2","title":"Astarte.Flow.Auth.Guardian.Plug.sign_out/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Auth.RealmPublicKeyProvider.html","title":"Astarte.Flow.Auth.RealmPublicKeyProvider","type":"behaviour"},{"doc":"","ref":"Astarte.Flow.Auth.RealmPublicKeyProvider.html#c:fetch_public_key/1","title":"Astarte.Flow.Auth.RealmPublicKeyProvider.fetch_public_key/1","type":"callback"},{"doc":"","ref":"Astarte.Flow.Auth.User.html","title":"Astarte.Flow.Auth.User","type":"module"},{"doc":"","ref":"Astarte.Flow.Auth.User.html#t:t/0","title":"Astarte.Flow.Auth.User.t/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.html","title":"Astarte.Flow.Blocks","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.html#check_default_blocks_conflict/1","title":"Astarte.Flow.Blocks.check_default_blocks_conflict/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.html#create_block/2","title":"Astarte.Flow.Blocks.create_block/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.html#delete_block/2","title":"Astarte.Flow.Blocks.delete_block/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.html#get_block/2","title":"Astarte.Flow.Blocks.get_block/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.html#list_blocks/1","title":"Astarte.Flow.Blocks.list_blocks/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Block.html","title":"Astarte.Flow.Blocks.Block","type":"module"},{"doc":"This is a producer_consumer block that sends messages to a Docker container. Messages are sent and received via AMQP. The block will manage the creation of the Container in a Kubernetes cluster using the Astarte Kubernetes Operator.","ref":"Astarte.Flow.Blocks.Container.html","title":"Astarte.Flow.Blocks.Container","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.Container.html#get_container_block/1","title":"Astarte.Flow.Blocks.Container.get_container_block/1","type":"function"},{"doc":"Starts the Container block. Options :id (required) - The id of the block, it has to be unique between all container blocks. :image (required) - The tag of the docker image that will be used by the block. :config - The Flow configuration that will be passed to the container. :connection - A keyword list containing the options that will be passed to AMQP.Connection.open/1 . Defaults to [] . :image_pull_secrets - An array of strings, representing the name of K8s secrets that will be used by the Pod created by the container block. This is needed if your image is pulled from a private container registry. :prefetch_count - The prefetch count of the AMQP channel. Defaults to 100. :amqp_client - A module that implements the Astarte.Flow.Blocks.Container.AMQPClient behaviour and that will be used to connect to AMQP. Defaults to Astarte.Flow.Blocks.Container.RabbitMQClient","ref":"Astarte.Flow.Blocks.Container.html#start_link/1","title":"Astarte.Flow.Blocks.Container.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Container.RabbitMQClient.html","title":"Astarte.Flow.Blocks.Container.RabbitMQClient","type":"module"},{"doc":"Initialize the AMQP client config","ref":"Astarte.Flow.Blocks.Container.RabbitMQClient.html#generate_config/1","title":"Astarte.Flow.Blocks.Container.RabbitMQClient.generate_config/1","type":"function"},{"doc":"Initialize the AMQP channel","ref":"Astarte.Flow.Blocks.Container.RabbitMQClient.html#setup/2","title":"Astarte.Flow.Blocks.Container.RabbitMQClient.setup/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DETSStorage.html","title":"Astarte.Flow.Blocks.DETSStorage","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Astarte.Flow.Blocks.DETSStorage.html#child_spec/1","title":"Astarte.Flow.Blocks.DETSStorage.child_spec/1","type":"function"},{"doc":"Delete a block from the dets table","ref":"Astarte.Flow.Blocks.DETSStorage.html#delete_block/2","title":"Astarte.Flow.Blocks.DETSStorage.delete_block/2","type":"function"},{"doc":"Fetch a block given its realm and its name","ref":"Astarte.Flow.Blocks.DETSStorage.html#fetch_block/2","title":"Astarte.Flow.Blocks.DETSStorage.fetch_block/2","type":"function"},{"doc":"Insert a block into the dets table","ref":"Astarte.Flow.Blocks.DETSStorage.html#insert_block/2","title":"Astarte.Flow.Blocks.DETSStorage.insert_block/2","type":"function"},{"doc":"List the blocks for a specific realm","ref":"Astarte.Flow.Blocks.DETSStorage.html#list_blocks/1","title":"Astarte.Flow.Blocks.DETSStorage.list_blocks/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DETSStorage.html#start_link/1","title":"Astarte.Flow.Blocks.DETSStorage.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DefaultBlocks.html","title":"Astarte.Flow.Blocks.DefaultBlocks","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.DefaultBlocks.html#fetch/1","title":"Astarte.Flow.Blocks.DefaultBlocks.fetch/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DefaultBlocks.html#list/0","title":"Astarte.Flow.Blocks.DefaultBlocks.list/0","type":"function"},{"doc":"This is a producer block that generates messages by polling consuming from an AMQP queue that contains a stream of Astarte.Core.Triggers.SimpleEvents.SimpleEvent generated by Data Updater Plant. To make Data Updater Plant populate the queue, a Trigger has to be installed, using the same routing_key that will be passed in the start_link options to this block. If the Event can't be decoded, no message is produced and the event is rejected from the queue. If the request succeeds, DeviceEventsProducer produces an %Astarte.Flow.Message{} containing these fields: key contains a key in the format REALM/DEVICE_ID/INTERFACE/PATH . data contains the value obtained by extracting the bson_value of the trigger. type is inferred from the bson_value of the trigger. timestamp contains the timestamp (in microseconds) contained in the trigger or, if it didn't contain one, the reception timestamp of the event.","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.html","title":"Astarte.Flow.Blocks.DeviceEventsProducer","type":"module"},{"doc":"Starts the DeviceEventsProducer . Options :exchange (required) - The name of the exchange the queue will be bound to :routing_key (required) - The routing key used to bind the queue to the exchange. :realm (required) - The realm the producer will listen to. :target_devices - A list of device IDs. If provided, only events coming from these devices will be processed. :queue - The name of the queue that gets declared by the block. Defaults to an autogenerated name. :connection - A keyword list containing the options that will be passed to AMQP.Connection.open/1 . Defaults to [] . :prefetch_count - The prefetch count of the AMQP channel. Defaults to 100. :client - A module that implements the Astarte.Flow.Blocks.DeviceEventsProducer.AMQPClient behaviour and that will be used to connect to AMQP. Defaults to Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.html#start_link/1","title":"Astarte.Flow.Blocks.DeviceEventsProducer.start_link/1","type":"function"},{"doc":"This module handles the decoding of Astarte Events and their transformation to Astarte Flow Messages","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.EventsDecoder.html","title":"Astarte.Flow.Blocks.DeviceEventsProducer.EventsDecoder","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.EventsDecoder.html#decode_simple_event/1","title":"Astarte.Flow.Blocks.DeviceEventsProducer.EventsDecoder.decode_simple_event/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.EventsDecoder.html#simple_event_to_message/1","title":"Astarte.Flow.Blocks.DeviceEventsProducer.EventsDecoder.simple_event_to_message/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient.html","title":"Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient","type":"module"},{"doc":"Initialize the AMQP client config","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient.html#generate_config/1","title":"Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient.generate_config/1","type":"function"},{"doc":"Initialize the AMQP channel","ref":"Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient.html#setup_channel/1","title":"Astarte.Flow.Blocks.DeviceEventsProducer.RabbitMQClient.setup_channel/1","type":"function"},{"doc":"This is a consumer block that takes data from incoming Message s and publishes it as an Astarte device, interpreting the key as &lt;realm&gt;/&lt;device_id&gt;/&lt;interface&gt;&lt;path&gt;. The devices are dynamically registered when their device id is first seens. Credentials secret obtained with the registration are stored in the chosen CredentialsStorage.","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.html","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool","type":"module"},{"doc":"Starts the DynamicVirtualDevicePool . Options :pairing_url (required) - base URL of the Astarte Pairing API instance the devices will connect to, e.g. https://astarte.api.example.com/pairing or http://localhost:4003 for a local installation. URL containing the API version suffix (i.e. /v1 ) are deprecated and will be removed in a future release. :pairing_jwt_map (required) - A map in the form %{realm_name =&gt; jwt} where jwt must be a JWT with the authorizations needed to register a device in that realm. :interface_provider (required) - The interface_provider that will be used by the spawned devices. :ignore_ssl_errors - A boolean to indicate wether devices have to ignore SSL errors when connecting to the broker. Defaults to false . :credentials_storage - The module used to store and fetch credentials secrets. Defaults to DETSCredentialsStorage . :pairing_agent - The module used to register the devices. Defaults to Astarte.API.Pairing.Agent","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.html#start_link/1","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.CredentialsStorage.html","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.CredentialsStorage","type":"behaviour"},{"doc":"","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.CredentialsStorage.html#c:fetch_credentials_secret/2","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.CredentialsStorage.fetch_credentials_secret/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.CredentialsStorage.html#c:store_credentials_secret/3","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.CredentialsStorage.store_credentials_secret/3","type":"callback"},{"doc":"","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.DETSCredentialsStorage.html","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.DETSCredentialsStorage","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.DETSCredentialsStorage.html#child_spec/1","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.DETSCredentialsStorage.child_spec/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.DETSCredentialsStorage.html#start_link/1","title":"Astarte.Flow.Blocks.DynamicVirtualDevicePool.DETSCredentialsStorage.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Filter.html","title":"Astarte.Flow.Blocks.Filter","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.Filter.html#start_link/1","title":"Astarte.Flow.Blocks.Filter.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Filter.Config.html","title":"Astarte.Flow.Blocks.Filter.Config","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.FilterFunctions.html","title":"Astarte.Flow.Blocks.FilterFunctions","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.FilterFunctions.html#make_filter/1","title":"Astarte.Flow.Blocks.FilterFunctions.make_filter/1","type":"function"},{"doc":"This is a consumer block that takes data from incoming Message and makes a POST request to the configured URL containing data . This block supports only incoming messages with type :binary , so serialization to binary format must be handled in a separate block before the message arrives here. The subtype of the message, if present, is added as Content-Type header. Additionally, static headers can be added to the POST requests with the initial configuration. For the time being, the delivery is best-effort (i.e. if a message is not delivered, it is discarded).","ref":"Astarte.Flow.Blocks.HttpSink.html","title":"Astarte.Flow.Blocks.HttpSink","type":"module"},{"doc":"Starts the HttpSink . Options :url (required) - The target URL for the POST request. :headers - A list of {key, value} tuples where key and value are String and represent headers to be set in the POST request. :ignore_ssl_errors - If true , ignore SSL errors that happen while performing the request. Defaults to false .","ref":"Astarte.Flow.Blocks.HttpSink.html#start_link/1","title":"Astarte.Flow.Blocks.HttpSink.start_link/1","type":"function"},{"doc":"This is a producer block that generates messages by polling HTTP URLs with a GET request. It works by specifying a base_url and a list of target_paths to perform requests on. HttpSource will perform GET requests in a round robin fashion on all target_paths , waiting polling_interval_ms between two consecutive requests. If the request can't be performed or an error status ( &gt;= 400 ) is returned, no message is produced. If the request succeeds, HttpSource produces an %Astarte.Flow.Message{} containing these fields: key contains the target_path of the request. data contains the body of the response. type is always :binary . subtype is populated with the contents of the content-type HTTP header, defaulting to &quot;application/octet-stream&quot; if it's not found. metadata contains the &quot;Astarte.Flow.Blocks.HttpSource.base_url&quot; key with base_url as value. Moreover, it contains all the HTTP headers contained in the response with their keys prefixed with &quot;Astarte.Flow.HttpSource.&quot; . timestamp contains the timestamp (in microseconds) the response was received.","ref":"Astarte.Flow.Blocks.HttpSource.html","title":"Astarte.Flow.Blocks.HttpSource","type":"module"},{"doc":"Starts the HttpSource . Options :base_url (required) - The base URL for the GET requests. This gets prepended to the target_path when performing a request. :target_paths (required) - A non-empty list of target paths for GET requests. :polling_interval_ms - The interval between two consecutive GET requests, in milliseconds. Defaults to 1000 ms. :headers - A list of {key, value} tuples where key and value are String and represent headers to be set in the GET request. Headers can also be passed as a String =&gt; String map. :ignore_ssl_errors - If true , ignore SSL errors that happen while performing the request. Defaults to false .","ref":"Astarte.Flow.Blocks.HttpSource.html#start_link/1","title":"Astarte.Flow.Blocks.HttpSource.start_link/1","type":"function"},{"doc":"This is a map block that takes data from incoming Message and makes a Message having a JSON serialized payload. The subtype of the message is set to &quot;application/json&quot; and the type is :binary .","ref":"Astarte.Flow.Blocks.JsonMapper.html","title":"Astarte.Flow.Blocks.JsonMapper","type":"module"},{"doc":"Starts the JsonMapper . Options :pretty - serialize the output to pretty format that is easier to read for humans. :template - a JSONTemplate applied right before serialization.","ref":"Astarte.Flow.Blocks.JsonMapper.html#start_link/1","title":"Astarte.Flow.Blocks.JsonMapper.start_link/1","type":"function"},{"doc":"Makes a new Message with JSON serialzed data, :binary type and &quot;application/json&quot; subtype.","ref":"Astarte.Flow.Blocks.JsonMapper.html#to_json/2","title":"Astarte.Flow.Blocks.JsonMapper.to_json/2","type":"function"},{"doc":"Transforms the incoming JSON message using the configured JSON template which makes use of JSONPath to extract data from the incoming message.","ref":"Astarte.Flow.Blocks.JsonPathMapper.html","title":"Astarte.Flow.Blocks.JsonPathMapper","type":"module"},{"doc":"Transforms the given message according to the configured template.","ref":"Astarte.Flow.Blocks.JsonPathMapper.html#json_path_transform/2","title":"Astarte.Flow.Blocks.JsonPathMapper.json_path_transform/2","type":"function"},{"doc":"Starts the JsonPathMapper . Options :template - output message template. It must be a valid JSON that makes use of JSONPath.","ref":"Astarte.Flow.Blocks.JsonPathMapper.html#start_link/1","title":"Astarte.Flow.Blocks.JsonPathMapper.start_link/1","type":"function"},{"doc":"Implements a simple logic less templating system that allows to write map templates with a syntax that resembles mustache syntax, that can be used for JSON templating.","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#compile_template/1","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.compile_template/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#render/2","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.render/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#t:compiled_item/0","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.compiled_item/0","type":"opaque"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#t:compiled_template/0","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.compiled_template/0","type":"opaque"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#t:rendered_template/0","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.rendered_template/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#t:template/0","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.template/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.html#t:template_base_type/0","title":"Astarte.Flow.Blocks.JsonPathMapper.JsonTemplate.template_base_type/0","type":"type"},{"doc":"This is a map block that takes an incoming Message and it transforms it using given Lua script. This block supports Lua 5.3 scripts. The incoming message will be provided to the script as message","ref":"Astarte.Flow.Blocks.LuaMapper.html","title":"Astarte.Flow.Blocks.LuaMapper","type":"module"},{"doc":"Executes the Lua script and returns the new message created using the script.","ref":"Astarte.Flow.Blocks.LuaMapper.html#lua_map/2","title":"Astarte.Flow.Blocks.LuaMapper.lua_map/2","type":"function"},{"doc":"Starts the LuaMapper . Options :script - a Lua 5.3 script. Defaults to &quot;return message;&quot; .","ref":"Astarte.Flow.Blocks.LuaMapper.html#start_link/1","title":"Astarte.Flow.Blocks.LuaMapper.start_link/1","type":"function"},{"doc":"Breaks a map message into several messages, one for each map item.","ref":"Astarte.Flow.Blocks.MapSplitter.html","title":"Astarte.Flow.Blocks.MapSplitter","type":"module"},{"doc":"Split a map message into a different message for each key.","ref":"Astarte.Flow.Blocks.MapSplitter.html#split_map/2","title":"Astarte.Flow.Blocks.MapSplitter.split_map/2","type":"function"},{"doc":"Starts the MapSplitter . Options :key_action - the action to apply to the message key, such as :none , {:replace, delimiter} , {:append, delimiter} and {:prepend, delimiter} . :fallback_action - fallback action that is performed when a message does not have map type, such as :discard , {:replace_key, new_key} and :pass_through .","ref":"Astarte.Flow.Blocks.MapSplitter.html#start_link/1","title":"Astarte.Flow.Blocks.MapSplitter.start_link/1","type":"function"},{"doc":"An Astarte Flow source that produces data by polling a Modbus device. This block is built to poll a single Modbus slave, if you want to poll multiple slaves you must instantiate multiple flows changing the slave id. The message contains these fields: key contains the name defined in the configuration data contains the data read from the Modbus device, converted with the format indicated in the configuration. type depends on the format indicated in the configuration. metadata contains the static metadata indicated in the configuration. timestamp contains the timestamp (in microseconds) the message was polled on. Since polling happens at regular intervals while Flow works in a demand-driven way, this block implements a queue to buffer incoming messages while waiting for consumer demand.","ref":"Astarte.Flow.Blocks.ModbusTCPSource.html","title":"Astarte.Flow.Blocks.ModbusTCPSource","type":"module"},{"doc":"Starts the ModbusTCPSource . Options host (required): the IP address of the Modbus master this block will connect to. slave_id (required): the slave id that will be polled. targets (required): an array of maps representing the polling targets. See the section below for the structure of the map. port : the TCP port. Defaults to 502, which is the standard Modbus TCP port. Target map Each map in the targets option must have this keys, with string keys: name (required): the name of the measured quantity. This will be used as key in the resulting Flow Message base_address (required): the address where the data starts. Depending on format , one or more registers will be read starting from this address. format (required): one of :int16 , :uint16 , :float32be , :float32le , :boolean . The be and le suffix in float32 format indicates the endianness, i.e. the order of the two 16 bits halves. modbus_type (required): one of :coil , :discrete_input , :input_register , :holding_register . polling_interval_ms (required): the interval between two polling on this target. Must be Caveat : currently this block only supports setting the same polling_interval_ms for all targets, this limitation will be removed in a future release. static_metadata : a map containing some static metadata that will be added to the message in the metadata field. It can be used to add information (e.g. units of measurement).","ref":"Astarte.Flow.Blocks.ModbusTCPSource.html#start_link/1","title":"Astarte.Flow.Blocks.ModbusTCPSource.start_link/1","type":"function"},{"doc":"An Astarte Flow consumer that publishes MQTT messages from incoming Flow messages. This block supports only incoming messages with type :binary , so serialization to binary format must be handled in a separate block before the message arrives here. When a message is received, MqttSink generates an MQTT publish with this conversion process: key is used as topic data is used as payload type must always be :binary , messages without a binary type are discarded","ref":"Astarte.Flow.Blocks.MqttSink.html","title":"Astarte.Flow.Blocks.MqttSink","type":"module"},{"doc":"Starts the MqttSource . Options broker_url (required): the URL of the broker the source will connect to. The transport will be deduced by the URL: if mqtts:// is used, SSL transport will be used, if mqtt:// is used, TCP transport will be used. client_id : the client id used to connect. Defaults to a random string. username : username used to authenticate to the broker. password : password used to authenticate to the broker. ca_cert_pem : a PEM encoded CA certificate. If not provided, the default CA trust store provided by :certifi will be used. client_cert_pem : a PEM encoded client certificate, used for mutual SSL authentication. If this is provided, also private_key_pem must be provided. private_key_pem : a PEM encoded private key, used for mutual SSL authentication. If this is provided, also client_cert_pem must be provided. ignore_ssl_errors : if true, accept invalid certificates (e.g. self-signed) when using SSL. qos : the qos that will be used to publish messages. Defaults to 0.","ref":"Astarte.Flow.Blocks.MqttSink.html#start_link/1","title":"Astarte.Flow.Blocks.MqttSink.start_link/1","type":"function"},{"doc":"An Astarte Flow source that produces data from an MQTT connection. When a message is received on a subscribed topic, MqttSource generates an %Astarte.Flow.Message{} containing these fields: key contains the topic on which the message was received. data contains the payload of the message. type is always :binary . subtype defaults to application/octet-stream but can be configured with the subtype option in start_link/1 . metadata contains the Astarte.Flow.Blocks.MqttSource.broker_url key with the broker url as value. timestamp contains the timestamp (in microseconds) the message was received on. Since MQTT is a push-driven protocol, this block implements a queue to buffer incoming messages while waiting for consumer demand.","ref":"Astarte.Flow.Blocks.MqttSource.html","title":"Astarte.Flow.Blocks.MqttSource","type":"module"},{"doc":"Starts the MqttSource . Options broker_url (required): the URL of the broker the source will connect to. The transport will be deduced by the URL: if mqtts:// is used, SSL transport will be used, if mqtt:// is used, TCP transport will be used. subscriptions (required): a non-empty list of topic filters to subscribe to. client_id : the client id used to connect. Defaults to a random string. username : username used to authenticate to the broker. password : password used to authenticate to the broker. ca_cert_pem : a PEM encoded CA certificate. If not provided, the default CA trust store provided by :certifi will be used. client_cert_pem : a PEM encoded client certificate, used for mutual SSL authentication. If this is provided, also private_key_pem must be provided. private_key_pem : a PEM encoded private key, used for mutual SSL authentication. If this is provided, also client_cert_pem must be provided. ignore_ssl_errors : if true, accept invalid certificates (e.g. self-signed) when using SSL. subtype : a MIME type that will be put as subtype in the generated Messages. Defaults to application/octet-stream","ref":"Astarte.Flow.Blocks.MqttSource.html#start_link/1","title":"Astarte.Flow.Blocks.MqttSource.start_link/1","type":"function"},{"doc":"Producer module that generates random messages of a specific type with a fixed key. The supported types are :integer , :real and :boolean . The data generated for each type is the following: :integer generates a random integer between :min and :max (defaults to min = 0 and max = 100 ). :real generates a random float between :min and :max (defaults to min = 0 and max = 1 ). :boolean generates true with probability :p (defaults to p = 0.5 ), otherwise false . The message timestamp will be generated with DateTime.utc_now().","ref":"Astarte.Flow.Blocks.RandomProducer.html","title":"Astarte.Flow.Blocks.RandomProducer","type":"module"},{"doc":"Starts the RandomProducer . Options :key (required) - A unicode string that will be used as key in the generated messages :type (required) - The type of data that will be generated. Supported types are :integer , :real and :boolean :min - Used with :integer and :real types to define a min value. :max - Used with :integer and :real types to define a max value. :p - Used with :boolean type to define the probability of the generator returning true . The value must be &gt;= 0 and &lt;= 1 . :delay_ms - If not nil , the block will wait delay_ms before emitting a new sample","ref":"Astarte.Flow.Blocks.RandomProducer.html#start_link/1","title":"Astarte.Flow.Blocks.RandomProducer.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.RandomProducer.html#t:boolean_option/0","title":"Astarte.Flow.Blocks.RandomProducer.boolean_option/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.RandomProducer.html#t:integer_option/0","title":"Astarte.Flow.Blocks.RandomProducer.integer_option/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.RandomProducer.html#t:option/0","title":"Astarte.Flow.Blocks.RandomProducer.option/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.RandomProducer.html#t:options/0","title":"Astarte.Flow.Blocks.RandomProducer.options/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.RandomProducer.html#t:real_option/0","title":"Astarte.Flow.Blocks.RandomProducer.real_option/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.RandomProducer.html#t:supported_types/0","title":"Astarte.Flow.Blocks.RandomProducer.supported_types/0","type":"type"},{"doc":"This block is a stateful realtime block, which reorders an out of order sequence of messages, and optionally removes any duplicate message.","ref":"Astarte.Flow.Blocks.Sorter.html","title":"Astarte.Flow.Blocks.Sorter","type":"module"},{"doc":"Process a message and stores it into the block state.","ref":"Astarte.Flow.Blocks.Sorter.html#process_message/3","title":"Astarte.Flow.Blocks.Sorter.process_message/3","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Sorter.html#start_link/1","title":"Astarte.Flow.Blocks.Sorter.start_link/1","type":"function"},{"doc":"Take any ready message.","ref":"Astarte.Flow.Blocks.Sorter.html#take_ready/2","title":"Astarte.Flow.Blocks.Sorter.take_ready/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Sorter.Config.html","title":"Astarte.Flow.Blocks.Sorter.Config","type":"module"},{"doc":"Initialize config from a keyword list. Options :deduplicate - true when messages deduplication is enabled, otherwise false. Two messages are duplicate when they have same timestamp and value (any other field is ignored). :delay_ms - the amount of time the message is kept for reorder and deduplicate operations.","ref":"Astarte.Flow.Blocks.Sorter.Config.html#from_keyword/1","title":"Astarte.Flow.Blocks.Sorter.Config.from_keyword/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Blocks.Sorter.Config.html#t:option/0","title":"Astarte.Flow.Blocks.Sorter.Config.option/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.Sorter.Config.html#t:t/0","title":"Astarte.Flow.Blocks.Sorter.Config.t/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.Sorter.State.html","title":"Astarte.Flow.Blocks.Sorter.State","type":"module"},{"doc":"","ref":"Astarte.Flow.Blocks.Sorter.State.html#t:t/0","title":"Astarte.Flow.Blocks.Sorter.State.t/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Blocks.Storage.html","title":"Astarte.Flow.Blocks.Storage","type":"behaviour"},{"doc":"","ref":"Astarte.Flow.Blocks.Storage.html#c:delete_block/2","title":"Astarte.Flow.Blocks.Storage.delete_block/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Blocks.Storage.html#c:fetch_block/2","title":"Astarte.Flow.Blocks.Storage.fetch_block/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Blocks.Storage.html#c:insert_block/2","title":"Astarte.Flow.Blocks.Storage.insert_block/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Blocks.Storage.html#c:list_blocks/1","title":"Astarte.Flow.Blocks.Storage.list_blocks/1","type":"callback"},{"doc":"This is a producer-consumer block that modifies the metadata field of incoming Message s by inserting, updating or removing keys using a static configuration.","ref":"Astarte.Flow.Blocks.UpdateMetadata.html","title":"Astarte.Flow.Blocks.UpdateMetadata","type":"module"},{"doc":"Starts the UpdateMetadata block. Options :metadata - The metadata map. All keys present in the object are either inserted or updated in the Message metadata, with the only exception that if a key has a value of null, it will be removed from metadata (required, object with string keys and string or null values)","ref":"Astarte.Flow.Blocks.UpdateMetadata.html#start_link/1","title":"Astarte.Flow.Blocks.UpdateMetadata.start_link/1","type":"function"},{"doc":"This is a consumer block that takes data from incoming Message s and publishes it as an Astarte device, interpreting the key as &lt;realm&gt;/&lt;device_id&gt;/&lt;interface&gt;&lt;path&gt;. The list of supported devices is configured using start_link/1 .","ref":"Astarte.Flow.Blocks.VirtualDevicePool.html","title":"Astarte.Flow.Blocks.VirtualDevicePool","type":"module"},{"doc":"Starts the VirtualDevicePool . Options :pairing_url (required) - base URL of the Astarte Pairing API instance the devices will connect to, e.g. https://astarte.api.example.com/pairing or http://localhost:4003 for a local installation. URL containing the API version suffix (i.e. /v1 ) are deprecated and will be removed in a future release. :devices (required) - A list of supported devices, each represented by its device_options (see &quot;Device options&quot; below). :ignore_ssl_errors - A boolean to indicate wether devices have to ignore SSL errors when connecting to the broker. Defaults to false . Device options :realm (required) :device_id (required) :credentials_secret (required) :interface_provider (required) See Astarte.Device.start_link/1 for more documentation.","ref":"Astarte.Flow.Blocks.VirtualDevicePool.html#start_link/1","title":"Astarte.Flow.Blocks.VirtualDevicePool.start_link/1","type":"function"},{"doc":"This module provides compatibility helpers to support multiple formats of configuration during the deprecation period.","ref":"Astarte.Flow.Compat.html","title":"Astarte.Flow.Compat","type":"module"},{"doc":"Removes the trailing /v1 from a pairing_url if it finds one, printing a warning.","ref":"Astarte.Flow.Compat.html#normalize_device_pairing_url/1","title":"Astarte.Flow.Compat.normalize_device_pairing_url/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Config.html","title":"Astarte.Flow.Config","type":"module"},{"doc":"Name of the Kubernetes instance of astarte which Flow will connect to Calling Astarte.Flow.Config.astarte_instance() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_ASTARTE_INSTANCE&quot; Type: :binary Default: &quot;astarte&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#astarte_instance/1","title":"Astarte.Flow.Config.astarte_instance/1","type":"function"},{"doc":"Name of the Kubernetes instance of astarte which Flow will connect to Bang version of Astarte.Flow.Config.astarte_instance/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#astarte_instance!/1","title":"Astarte.Flow.Config.astarte_instance!/1","type":"function"},{"doc":"Returns the default amqp connection parameters","ref":"Astarte.Flow.Config.html#default_amqp_connection!/0","title":"Astarte.Flow.Config.default_amqp_connection!/0","type":"function"},{"doc":"Default RabbitMQ connection host Calling Astarte.Flow.Config.default_amqp_connection_host() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_HOST&quot; Type: :binary Default: &quot;astarte&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_host/1","title":"Astarte.Flow.Config.default_amqp_connection_host/1","type":"function"},{"doc":"Default RabbitMQ connection host Bang version of Astarte.Flow.Config.default_amqp_connection_host/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_host!/1","title":"Astarte.Flow.Config.default_amqp_connection_host!/1","type":"function"},{"doc":"Default RabbitMQ connection password Calling Astarte.Flow.Config.default_amqp_connection_password() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_PASSWORD&quot; Type: :binary Default: &quot;astarte&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_password/1","title":"Astarte.Flow.Config.default_amqp_connection_password/1","type":"function"},{"doc":"Default RabbitMQ connection password Bang version of Astarte.Flow.Config.default_amqp_connection_password/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_password!/1","title":"Astarte.Flow.Config.default_amqp_connection_password!/1","type":"function"},{"doc":"Default RabbitMQ connection port Calling Astarte.Flow.Config.default_amqp_connection_port() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_PORT&quot; Type: :integer Default: 5672 Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_port/1","title":"Astarte.Flow.Config.default_amqp_connection_port/1","type":"function"},{"doc":"Default RabbitMQ connection port Bang version of Astarte.Flow.Config.default_amqp_connection_port/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_port!/1","title":"Astarte.Flow.Config.default_amqp_connection_port!/1","type":"function"},{"doc":"Specifies the certificates of the root Certificate Authorities to be trusted. When not specified, the bundled cURL certificate bundle will be used. Calling Astarte.Flow.Config.default_amqp_connection_ssl_ca_file() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_SSL_CA_FILE&quot; Type: :binary Default: nil Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_ca_file/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_ca_file/1","type":"function"},{"doc":"Specifies the certificates of the root Certificate Authorities to be trusted. When not specified, the bundled cURL certificate bundle will be used. Bang version of Astarte.Flow.Config.default_amqp_connection_ssl_ca_file/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_ca_file!/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_ca_file!/1","type":"function"},{"doc":"Specify the hostname to be used in TLS Server Name Indication extension. If not specified, the amqp host will be used. This value is used only if Server Name Indication is enabled. Calling Astarte.Flow.Config.default_amqp_connection_ssl_custom_sni() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_SSL_CUSTOM_SNI&quot; Type: :binary Default: nil Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_custom_sni/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_custom_sni/1","type":"function"},{"doc":"Specify the hostname to be used in TLS Server Name Indication extension. If not specified, the amqp host will be used. This value is used only if Server Name Indication is enabled. Bang version of Astarte.Flow.Config.default_amqp_connection_ssl_custom_sni/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_custom_sni!/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_custom_sni!/1","type":"function"},{"doc":"Disable Server Name Indication. Defaults to false. Calling Astarte.Flow.Config.default_amqp_connection_ssl_disable_sni() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_SSL_DISABLE_SNI&quot; Type: :boolean Default: false Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_disable_sni/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_disable_sni/1","type":"function"},{"doc":"Disable Server Name Indication. Defaults to false. Bang version of Astarte.Flow.Config.default_amqp_connection_ssl_disable_sni/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_disable_sni!/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_disable_sni!/1","type":"function"},{"doc":"Enable SSL. If not specified SSL is disabled. Calling Astarte.Flow.Config.default_amqp_connection_ssl_enabled() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_SSL_ENABLED&quot; Type: :boolean Default: false Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_enabled/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_enabled/1","type":"function"},{"doc":"Enable SSL. If not specified SSL is disabled. Bang version of Astarte.Flow.Config.default_amqp_connection_ssl_enabled/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_ssl_enabled!/1","title":"Astarte.Flow.Config.default_amqp_connection_ssl_enabled!/1","type":"function"},{"doc":"Default RabbitMQ connection username Calling Astarte.Flow.Config.default_amqp_connection_username() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_USERNAME&quot; Type: :binary Default: &quot;astarte&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_username/1","title":"Astarte.Flow.Config.default_amqp_connection_username/1","type":"function"},{"doc":"Default RabbitMQ connection username Bang version of Astarte.Flow.Config.default_amqp_connection_username/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_username!/1","title":"Astarte.Flow.Config.default_amqp_connection_username!/1","type":"function"},{"doc":"Default RabbitMQ connection virtual host Calling Astarte.Flow.Config.default_amqp_connection_virtual_host() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_CONNECTION_VIRTUAL_HOST&quot; Type: :binary Default: &quot;/&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_connection_virtual_host/1","title":"Astarte.Flow.Config.default_amqp_connection_virtual_host/1","type":"function"},{"doc":"Default RabbitMQ connection virtual host Bang version of Astarte.Flow.Config.default_amqp_connection_virtual_host/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_connection_virtual_host!/1","title":"Astarte.Flow.Config.default_amqp_connection_virtual_host!/1","type":"function"},{"doc":"Default RabbitMQ prefetch count for each channel Calling Astarte.Flow.Config.default_amqp_prefetch_count() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DEFAULT_AMQP_PREFETCH_COUNT&quot; Type: :integer Default: 100 Required: false Cached: true","ref":"Astarte.Flow.Config.html#default_amqp_prefetch_count/1","title":"Astarte.Flow.Config.default_amqp_prefetch_count/1","type":"function"},{"doc":"Default RabbitMQ prefetch count for each channel Bang version of Astarte.Flow.Config.default_amqp_prefetch_count/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#default_amqp_prefetch_count!/1","title":"Astarte.Flow.Config.default_amqp_prefetch_count!/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Calling Astarte.Flow.Config.disable_authentication() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_DISABLE_AUTHENTICATION&quot; Type: :boolean Default: false Required: false Cached: true","ref":"Astarte.Flow.Config.html#disable_authentication/1","title":"Astarte.Flow.Config.disable_authentication/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Bang version of Astarte.Flow.Config.disable_authentication/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#disable_authentication!/1","title":"Astarte.Flow.Config.disable_authentication!/1","type":"function"},{"doc":"The directory where Flow will persist its dets tables Calling Astarte.Flow.Config.persistency_dir() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_PERSISTENCY_DIR&quot; Type: :binary Default: &quot;&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#persistency_dir/1","title":"Astarte.Flow.Config.persistency_dir/1","type":"function"},{"doc":"The directory where Flow will persist its dets tables Bang version of Astarte.Flow.Config.persistency_dir/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#persistency_dir!/1","title":"Astarte.Flow.Config.persistency_dir!/1","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.astarte_instance/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_astarte_instance/2","title":"Astarte.Flow.Config.put_astarte_instance/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_host/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_host/2","title":"Astarte.Flow.Config.put_default_amqp_connection_host/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_password/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_password/2","title":"Astarte.Flow.Config.put_default_amqp_connection_password/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_port/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_port/2","title":"Astarte.Flow.Config.put_default_amqp_connection_port/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_ssl_ca_file/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_ssl_ca_file/2","title":"Astarte.Flow.Config.put_default_amqp_connection_ssl_ca_file/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_ssl_custom_sni/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_ssl_custom_sni/2","title":"Astarte.Flow.Config.put_default_amqp_connection_ssl_custom_sni/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_ssl_disable_sni/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_ssl_disable_sni/2","title":"Astarte.Flow.Config.put_default_amqp_connection_ssl_disable_sni/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_ssl_enabled/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_ssl_enabled/2","title":"Astarte.Flow.Config.put_default_amqp_connection_ssl_enabled/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_username/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_username/2","title":"Astarte.Flow.Config.put_default_amqp_connection_username/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_connection_virtual_host/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_connection_virtual_host/2","title":"Astarte.Flow.Config.put_default_amqp_connection_virtual_host/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.default_amqp_prefetch_count/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_default_amqp_prefetch_count/2","title":"Astarte.Flow.Config.put_default_amqp_prefetch_count/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.disable_authentication/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_disable_authentication/2","title":"Astarte.Flow.Config.put_disable_authentication/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.persistency_dir/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_persistency_dir/2","title":"Astarte.Flow.Config.put_persistency_dir/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.realm_public_key_provider/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_realm_public_key_provider/2","title":"Astarte.Flow.Config.put_realm_public_key_provider/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.realm_public_keys_dir/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_realm_public_keys_dir/2","title":"Astarte.Flow.Config.put_realm_public_keys_dir/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.target_namespace/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_target_namespace/2","title":"Astarte.Flow.Config.put_target_namespace/2","type":"function"},{"doc":"Puts the value to Astarte.Flow.Config.xandra_nodes/0 . Optionally, receives the namespace .","ref":"Astarte.Flow.Config.html#put_xandra_nodes/2","title":"Astarte.Flow.Config.put_xandra_nodes/2","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Calling Astarte.Flow.Config.realm_public_key_provider() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_REALM_PUBLIC_KEY_PROVIDER&quot; Type: Astarte.Flow.Auth.RealmPublicKeyProvider Default: nil Required: false Cached: true","ref":"Astarte.Flow.Config.html#realm_public_key_provider/1","title":"Astarte.Flow.Config.realm_public_key_provider/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Bang version of Astarte.Flow.Config.realm_public_key_provider/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#realm_public_key_provider!/1","title":"Astarte.Flow.Config.realm_public_key_provider!/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Calling Astarte.Flow.Config.realm_public_keys_dir() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_REALM_PUBLIC_KEYS_DIR&quot; Type: :binary Default: nil Required: false Cached: true","ref":"Astarte.Flow.Config.html#realm_public_keys_dir/1","title":"Astarte.Flow.Config.realm_public_keys_dir/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Bang version of Astarte.Flow.Config.realm_public_keys_dir/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#realm_public_keys_dir!/1","title":"Astarte.Flow.Config.realm_public_keys_dir!/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.astarte_instance/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_astarte_instance/1","title":"Astarte.Flow.Config.reload_astarte_instance/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_host/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_host/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_host/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_password/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_password/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_password/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_port/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_port/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_port/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_ssl_ca_file/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_ssl_ca_file/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_ssl_ca_file/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_ssl_custom_sni/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_ssl_custom_sni/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_ssl_custom_sni/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_ssl_disable_sni/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_ssl_disable_sni/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_ssl_disable_sni/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_ssl_enabled/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_ssl_enabled/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_ssl_enabled/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_username/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_username/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_username/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_connection_virtual_host/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_connection_virtual_host/1","title":"Astarte.Flow.Config.reload_default_amqp_connection_virtual_host/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.default_amqp_prefetch_count/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_default_amqp_prefetch_count/1","title":"Astarte.Flow.Config.reload_default_amqp_prefetch_count/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.disable_authentication/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_disable_authentication/1","title":"Astarte.Flow.Config.reload_disable_authentication/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.persistency_dir/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_persistency_dir/1","title":"Astarte.Flow.Config.reload_persistency_dir/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.realm_public_key_provider/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_realm_public_key_provider/1","title":"Astarte.Flow.Config.reload_realm_public_key_provider/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.realm_public_keys_dir/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_realm_public_keys_dir/1","title":"Astarte.Flow.Config.reload_realm_public_keys_dir/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.target_namespace/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_target_namespace/1","title":"Astarte.Flow.Config.reload_target_namespace/1","type":"function"},{"doc":"Reloads the value for Astarte.Flow.Config.xandra_nodes/0 . Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#reload_xandra_nodes/1","title":"Astarte.Flow.Config.reload_xandra_nodes/1","type":"function"},{"doc":"Kubernetes namespace where Flow will deploy its containers Calling Astarte.Flow.Config.target_namespace() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;FLOW_TARGET_NAMESPACE&quot; Type: :binary Default: &quot;astarte&quot; Required: false Cached: true","ref":"Astarte.Flow.Config.html#target_namespace/1","title":"Astarte.Flow.Config.target_namespace/1","type":"function"},{"doc":"Kubernetes namespace where Flow will deploy its containers Bang version of Astarte.Flow.Config.target_namespace/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#target_namespace!/1","title":"Astarte.Flow.Config.target_namespace!/1","type":"function"},{"doc":"Creates a template for OS environment variables given a filename . Additionally, it can receive a list of options: type : What kind of file it will generate ( :elixir , :unix , :windows ). namespace : Namespace for the variables.","ref":"Astarte.Flow.Config.html#template/2","title":"Astarte.Flow.Config.template/2","type":"function"},{"doc":"Validates that all required variables are present. Returns :ok if they are, {:error, errors} if they are not. errors will be a list of all errors encountered while getting required variables. It is possible to provide a namespace as argument (defaults to nil ).","ref":"Astarte.Flow.Config.html#validate/1","title":"Astarte.Flow.Config.validate/1","type":"function"},{"doc":"Validates that all required variables are present. Returns :ok if they are, raises if they're not. It is possible to provide a namespace as argument (defaults to nil ).","ref":"Astarte.Flow.Config.html#validate!/1","title":"Astarte.Flow.Config.validate!/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Calling Astarte.Flow.Config.xandra_nodes() will ensure the following: Binding order: [:system, :config] OS environment variable: &quot;CASSANDRA_NODES&quot; Type: Astarte.Flow.Config.XandraNodes Default: nil Required: false Cached: true","ref":"Astarte.Flow.Config.html#xandra_nodes/1","title":"Astarte.Flow.Config.xandra_nodes/1","type":"function"},{"doc":"Disables the authentication. CHANGING IT TO TRUE IS GENERALLY A REALLY BAD IDEA IN A PRODUCTION ENVIRONMENT, IF YOU DON'T KNOW WHAT YOU ARE DOING.&quot; Bang version of Astarte.Flow.Config.xandra_nodes/0 (fails on error). Optionally, receives the namespace for the variable.","ref":"Astarte.Flow.Config.html#xandra_nodes!/1","title":"Astarte.Flow.Config.xandra_nodes!/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Config.html#t:options/0","title":"Astarte.Flow.Config.options/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Config.html#t:ssl_option/0","title":"Astarte.Flow.Config.ssl_option/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Config.html#t:ssl_options/0","title":"Astarte.Flow.Config.ssl_options/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Config.XandraNodes.html","title":"Astarte.Flow.Config.XandraNodes","type":"module"},{"doc":"The Flows context.","ref":"Astarte.Flow.Flows.html","title":"Astarte.Flow.Flows","type":"module"},{"doc":"Creates a flow. Examples iex&gt; create_flow ( %{ field : value } ) { :ok , % Flow { } } iex&gt; create_flow ( %{ field : bad_value } ) { :error , ... }","ref":"Astarte.Flow.Flows.html#create_flow/2","title":"Astarte.Flow.Flows.create_flow/2","type":"function"},{"doc":"Deletes a Flow. Examples iex&gt; delete_flow ( flow ) { :ok , % Flow { } } iex&gt; delete_flow ( flow ) { :error , ... }","ref":"Astarte.Flow.Flows.html#delete_flow/2","title":"Astarte.Flow.Flows.delete_flow/2","type":"function"},{"doc":"Gets a single flow. Returns {:error, :not_found} if the flow does not exist.","ref":"Astarte.Flow.Flows.html#get_flow/2","title":"Astarte.Flow.Flows.get_flow/2","type":"function"},{"doc":"Returns the list of flows for a realm.","ref":"Astarte.Flow.Flows.html#list_flows/1","title":"Astarte.Flow.Flows.list_flows/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Flows.DETSStorage.html","title":"Astarte.Flow.Flows.DETSStorage","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Astarte.Flow.Flows.DETSStorage.html#child_spec/1","title":"Astarte.Flow.Flows.DETSStorage.child_spec/1","type":"function"},{"doc":"Delete a flow from the dets table","ref":"Astarte.Flow.Flows.DETSStorage.html#delete_flow/2","title":"Astarte.Flow.Flows.DETSStorage.delete_flow/2","type":"function"},{"doc":"Return a list of all saved Flows in the form {realm, %Flow{}}","ref":"Astarte.Flow.Flows.DETSStorage.html#get_all_flows/0","title":"Astarte.Flow.Flows.DETSStorage.get_all_flows/0","type":"function"},{"doc":"Insert a flow into the dets table","ref":"Astarte.Flow.Flows.DETSStorage.html#insert_flow/2","title":"Astarte.Flow.Flows.DETSStorage.insert_flow/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Flows.DETSStorage.html#start_link/1","title":"Astarte.Flow.Flows.DETSStorage.start_link/1","type":"function"},{"doc":"This module implements an embedded_schema representing a Flow and also the GenServer responsible of starting and monitoring the Flow.","ref":"Astarte.Flow.Flows.Flow.html","title":"Astarte.Flow.Flows.Flow","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Astarte.Flow.Flows.Flow.html#child_spec/1","title":"Astarte.Flow.Flows.Flow.child_spec/1","type":"function"},{"doc":"See get_flow/2 .","ref":"Astarte.Flow.Flows.Flow.html#get_flow/1","title":"Astarte.Flow.Flows.Flow.get_flow/1","type":"function"},{"doc":"Returns the %Flow{} struct that was used to create the flow.","ref":"Astarte.Flow.Flows.Flow.html#get_flow/2","title":"Astarte.Flow.Flows.Flow.get_flow/2","type":"function"},{"doc":"Start a Flow as linked process. Arguments: realm : the realm the Flow belongs to. flow : a %Flow{} struct with the parameters of the Flow.","ref":"Astarte.Flow.Flows.Flow.html#start_link/1","title":"Astarte.Flow.Flows.Flow.start_link/1","type":"function"},{"doc":"Returns a Stream created by calling GenStage.stream/1 on the last stage of the Flow.","ref":"Astarte.Flow.Flows.Flow.html#tap/2","title":"Astarte.Flow.Flows.Flow.tap/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Flows.Flow.State.html","title":"Astarte.Flow.Flows.Flow.State","type":"module"},{"doc":"","ref":"Astarte.Flow.Flows.Storage.html","title":"Astarte.Flow.Flows.Storage","type":"behaviour"},{"doc":"","ref":"Astarte.Flow.Flows.Storage.html#c:delete_flow/2","title":"Astarte.Flow.Flows.Storage.delete_flow/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Flows.Storage.html#c:get_all_flows/0","title":"Astarte.Flow.Flows.Storage.get_all_flows/0","type":"callback"},{"doc":"","ref":"Astarte.Flow.Flows.Storage.html#c:insert_flow/2","title":"Astarte.Flow.Flows.Storage.insert_flow/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.K8s.html","title":"Astarte.Flow.K8s","type":"module"},{"doc":"","ref":"Astarte.Flow.K8s.html#container_block_resource/1","title":"Astarte.Flow.K8s.container_block_resource/1","type":"function"},{"doc":"","ref":"Astarte.Flow.K8s.html#create_flow/4","title":"Astarte.Flow.K8s.create_flow/4","type":"function"},{"doc":"","ref":"Astarte.Flow.K8s.html#delete_flow/1","title":"Astarte.Flow.K8s.delete_flow/1","type":"function"},{"doc":"","ref":"Astarte.Flow.K8s.html#flow_custom_resource/4","title":"Astarte.Flow.K8s.flow_custom_resource/4","type":"function"},{"doc":"","ref":"Astarte.Flow.K8s.html#flow_status/1","title":"Astarte.Flow.K8s.flow_status/1","type":"function"},{"doc":"","ref":"Astarte.Flow.K8s.html#try_delete_flow/1","title":"Astarte.Flow.K8s.try_delete_flow/1","type":"function"},{"doc":"","ref":"Astarte.Flow.K8s.ContainerBlock.html","title":"Astarte.Flow.K8s.ContainerBlock","type":"module"},{"doc":"","ref":"Astarte.Flow.K8s.ContainerBlock.html#t:t/0","title":"Astarte.Flow.K8s.ContainerBlock.t/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html","title":"Astarte.Flow.Message","type":"module"},{"doc":"","ref":"Astarte.Flow.Message.html#deserialize_type/1","title":"Astarte.Flow.Message.deserialize_type/1","type":"function"},{"doc":"Converts a message map to a Message struct, this function is useful for handling JSON decoded messages. Examples iex&gt; %{ ...&gt; &quot;schema&quot; =&gt; &quot;astarte_flow/message/v0.1&quot; , ...&gt; &quot;data&quot; =&gt; 42 , ...&gt; &quot;key&quot; =&gt; &quot;meaning-of-life&quot; , ...&gt; &quot;metadata&quot; =&gt; %{ } , ...&gt; &quot;timestamp&quot; =&gt; 1551884045074 , ...&gt; &quot;timestamp_us&quot; =&gt; 181 , ...&gt; &quot;type&quot; =&gt; &quot;integer&quot; ...&gt; } ...&gt; |&gt; Message . from_map ( ) { :ok , % Message { data : 42 , key : &quot;meaning-of-life&quot; , metadata : %{ } , timestamp : 1551884045074181 , type : :integer } } iex&gt; %{ ...&gt; &quot;schema&quot; =&gt; &quot;astarte_flow/message/v0.1&quot; , ...&gt; } ...&gt; |&gt; Message . from_map ( ) { :error , :invalid_message } iex&gt; Message . from_map ( %{ } ) { :error , :invalid_message }","ref":"Astarte.Flow.Message.html#from_map/1","title":"Astarte.Flow.Message.from_map/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Message.html#serialize_type/1","title":"Astarte.Flow.Message.serialize_type/1","type":"function"},{"doc":"Converts a Message struct to a serialization friendly map, so it can be used with a JSON serializer. Examples iex&gt; % Message { ...&gt; data : 42 , ...&gt; key : &quot;meaning-of-life&quot; , ...&gt; metadata : %{ } , ...&gt; timestamp : 1551884045074181 , ...&gt; type : :integer ...&gt; } ...&gt; |&gt; Message . to_map ( ) %{ &quot;schema&quot; =&gt; &quot;astarte_flow/message/v0.1&quot; , &quot;data&quot; =&gt; 42 , &quot;key&quot; =&gt; &quot;meaning-of-life&quot; , &quot;metadata&quot; =&gt; %{ } , &quot;timestamp&quot; =&gt; 1551884045074 , &quot;timestamp_us&quot; =&gt; 181 , &quot;type&quot; =&gt; &quot;integer&quot; } iex&gt; % Message { ...&gt; data : &lt;&lt; 0 , 1 , 2 , 0 &gt;&gt; , ...&gt; key : &quot;binaries_stream&quot; , ...&gt; metadata : %{ } , ...&gt; timestamp : 1551884045074181 , ...&gt; type : :binary , ...&gt; subtype : &quot;application/octet-stream&quot; ...&gt; } ...&gt; |&gt; Message . to_map ( ) %{ &quot;schema&quot; =&gt; &quot;astarte_flow/message/v0.1&quot; , &quot;data&quot; =&gt; &quot;AAECAA==&quot; , &quot;key&quot; =&gt; &quot;binaries_stream&quot; , &quot;metadata&quot; =&gt; %{ } , &quot;timestamp&quot; =&gt; 1551884045074 , &quot;timestamp_us&quot; =&gt; 181 , &quot;type&quot; =&gt; &quot;binary&quot; , &quot;subtype&quot; =&gt; &quot;application/octet-stream&quot; } iex&gt; % Message { ...&gt; data : %{ ...&gt; &quot;a&quot; =&gt; - 1 , ...&gt; &quot;b&quot; =&gt; &quot;Ciao \\n &quot; ...&gt; } , ...&gt; key : &quot;binaries_stream&quot; , ...&gt; metadata : %{ } , ...&gt; timestamp : 1551884045074181 , ...&gt; type : %{ ...&gt; &quot;a&quot; =&gt; :real , ...&gt; &quot;b&quot; =&gt; :binary ...&gt; } , ...&gt; subtype : %{ ...&gt; &quot;b&quot; =&gt; &quot;text/plain&quot; ...&gt; } ...&gt; } ...&gt; |&gt; Message . to_map ( ) %{ &quot;schema&quot; =&gt; &quot;astarte_flow/message/v0.1&quot; , &quot;data&quot; =&gt; %{ &quot;a&quot; =&gt; - 1 , &quot;b&quot; =&gt; &quot;Q2lhbwo=&quot; } , &quot;key&quot; =&gt; &quot;binaries_stream&quot; , &quot;metadata&quot; =&gt; %{ } , &quot;timestamp&quot; =&gt; 1551884045074 , &quot;timestamp_us&quot; =&gt; 181 , &quot;type&quot; =&gt; %{ &quot;a&quot; =&gt; &quot;real&quot; , &quot;b&quot; =&gt; &quot;binary&quot; } , &quot;subtype&quot; =&gt; %{ &quot;b&quot; =&gt; &quot;text/plain&quot; } }","ref":"Astarte.Flow.Message.html#to_map/1","title":"Astarte.Flow.Message.to_map/1","type":"function"},{"doc":"Converts a &quot;wrapped&quot; value to a value that can be used as a Message data. Examples iex&gt; Message . unwrap_data ( 42 , :integer ) { :ok , 42 } iex&gt; Message . unwrap_data ( 0.5 , :real ) { :ok , 0.5 } iex&gt; Message . unwrap_data ( true , :boolean ) { :ok , true } iex&gt; Message . unwrap_data ( &quot;dGVzdA==&quot; , :binary ) { :ok , &quot;test&quot; } iex&gt; Message . unwrap_data ( &quot;Hello World&quot; , :string ) { :ok , &quot;Hello World&quot; } iex&gt; Message . unwrap_data ( [ 1 , 2 , 3 ] , { :array , :integer } ) { :ok , [ 1 , 2 , 3 ] } iex&gt; Message . unwrap_data ( [ 1 , 2.5 , 3 ] , { :array , :integer } ) { :error , :invalid_data } iex&gt; %{ ...&gt; &quot;key1&quot; =&gt; &quot;AAECAQA=&quot; , ...&gt; &quot;key2&quot; =&gt; [ - 1 , 0 , 0.5 , 1 ] ...&gt; } ...&gt; |&gt; Message . unwrap_data ( %{ &quot;key1&quot; =&gt; :binary , &quot;key2&quot; =&gt; { :array , :real } } ) { :ok , %{ &quot;key1&quot; =&gt; &lt;&lt; 0 , 1 , 2 , 1 , 0 &gt;&gt; , &quot;key2&quot; =&gt; [ - 1 , 0 , 0.5 , 1 ] } }","ref":"Astarte.Flow.Message.html#unwrap_data/2","title":"Astarte.Flow.Message.unwrap_data/2","type":"function"},{"doc":"Converts a value to a &quot;wrapped&quot; value that can be easily serialized. Examples iex&gt; Message . wrap_data ( 42 , :integer ) 42 iex&gt; Message . wrap_data ( 0.5 , :real ) 0.5 iex&gt; Message . wrap_data ( false , :boolean ) false iex&gt; Message . wrap_data ( &lt;&lt; 0 , 1 , 2 , 3 &gt;&gt; , :binary ) &quot;AAECAw==&quot; iex&gt; Message . wrap_data ( &quot;Hello World&quot; , :string ) &quot;Hello World&quot; iex&gt; Message . wrap_data ( [ 0 , 1 , 2 ] , { :array , :integer } ) [ 0 , 1 , 2 ] iex&gt; %{ &quot;my_key&quot; =&gt; &lt;&lt; 0 , 1 &gt;&gt; } ...&gt; |&gt; Message . wrap_data ( %{ &quot;my_key&quot; =&gt; :binary } ) %{ &quot;my_key&quot; =&gt; &quot;AAE=&quot; }","ref":"Astarte.Flow.Message.html#wrap_data/2","title":"Astarte.Flow.Message.wrap_data/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Message.html#t:basic_data/0","title":"Astarte.Flow.Message.basic_data/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:basic_data_type/0","title":"Astarte.Flow.Message.basic_data_type/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:data/0","title":"Astarte.Flow.Message.data/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:data_type/0","title":"Astarte.Flow.Message.data_type/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:data_type_with_array/0","title":"Astarte.Flow.Message.data_type_with_array/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:data_with_array/0","title":"Astarte.Flow.Message.data_with_array/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:message_metadata/0","title":"Astarte.Flow.Message.message_metadata/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:message_timestamp/0","title":"Astarte.Flow.Message.message_timestamp/0","type":"type"},{"doc":"","ref":"Astarte.Flow.Message.html#t:subtype/0","title":"Astarte.Flow.Message.subtype/0","type":"type"},{"doc":"An Astarte Flow message. :key : a unicode string that identifies the stream the message belongs to. :metadata : additional message metadata. :type': message data type (e.g. integer, real, boolean, etc...). * :subtype : a string that represents the subtype, that is a mimetype for binaries. * :timestamp : timestamp in microseconds. * :data`: the message payload.","ref":"Astarte.Flow.Message.html#t:t/0","title":"Astarte.Flow.Message.t/0","type":"type"},{"doc":"","ref":"Astarte.Flow.PipelineBuilder.Error.html","title":"Astarte.Flow.PipelineBuilder.Error","type":"module"},{"doc":"","ref":"Astarte.Flow.Pipelines.html","title":"Astarte.Flow.Pipelines","type":"module"},{"doc":"","ref":"Astarte.Flow.Pipelines.html#create_pipeline/2","title":"Astarte.Flow.Pipelines.create_pipeline/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.html#delete_pipeline/2","title":"Astarte.Flow.Pipelines.delete_pipeline/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.html#get_pipeline/2","title":"Astarte.Flow.Pipelines.get_pipeline/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.html#list_pipelines/1","title":"Astarte.Flow.Pipelines.list_pipelines/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.DETSStorage.html","title":"Astarte.Flow.Pipelines.DETSStorage","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Astarte.Flow.Pipelines.DETSStorage.html#child_spec/1","title":"Astarte.Flow.Pipelines.DETSStorage.child_spec/1","type":"function"},{"doc":"Delete a pipeline from the dets table","ref":"Astarte.Flow.Pipelines.DETSStorage.html#delete_pipeline/2","title":"Astarte.Flow.Pipelines.DETSStorage.delete_pipeline/2","type":"function"},{"doc":"Fetch a pipeline given its realm and its name","ref":"Astarte.Flow.Pipelines.DETSStorage.html#fetch_pipeline/2","title":"Astarte.Flow.Pipelines.DETSStorage.fetch_pipeline/2","type":"function"},{"doc":"Insert a pipeline into the dets table","ref":"Astarte.Flow.Pipelines.DETSStorage.html#insert_pipeline/2","title":"Astarte.Flow.Pipelines.DETSStorage.insert_pipeline/2","type":"function"},{"doc":"List the pipelines for a specific realm","ref":"Astarte.Flow.Pipelines.DETSStorage.html#list_pipelines/1","title":"Astarte.Flow.Pipelines.DETSStorage.list_pipelines/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.DETSStorage.html#start_link/1","title":"Astarte.Flow.Pipelines.DETSStorage.start_link/1","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.Pipeline.html","title":"Astarte.Flow.Pipelines.Pipeline","type":"module"},{"doc":"","ref":"Astarte.Flow.Pipelines.Pipeline.html#validate_pipeline_source/2","title":"Astarte.Flow.Pipelines.Pipeline.validate_pipeline_source/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.Pipeline.html#validate_schema/2","title":"Astarte.Flow.Pipelines.Pipeline.validate_schema/2","type":"function"},{"doc":"","ref":"Astarte.Flow.Pipelines.Storage.html","title":"Astarte.Flow.Pipelines.Storage","type":"behaviour"},{"doc":"","ref":"Astarte.Flow.Pipelines.Storage.html#c:delete_pipeline/2","title":"Astarte.Flow.Pipelines.Storage.delete_pipeline/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Pipelines.Storage.html#c:fetch_pipeline/2","title":"Astarte.Flow.Pipelines.Storage.fetch_pipeline/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Pipelines.Storage.html#c:insert_pipeline/2","title":"Astarte.Flow.Pipelines.Storage.insert_pipeline/2","type":"callback"},{"doc":"","ref":"Astarte.Flow.Pipelines.Storage.html#c:list_pipelines/1","title":"Astarte.Flow.Pipelines.Storage.list_pipelines/1","type":"callback"},{"doc":"","ref":"Astarte.Flow.RestoreFlowsTask.html","title":"Astarte.Flow.RestoreFlowsTask","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. arg is passed as the argument to Task.start_link/1 in the :start field of the spec. For more information, see the Supervisor module, the Supervisor.child_spec/2 function and the Supervisor.child_spec/0 type.","ref":"Astarte.Flow.RestoreFlowsTask.html#child_spec/1","title":"Astarte.Flow.RestoreFlowsTask.child_spec/1","type":"function"},{"doc":"","ref":"Astarte.Flow.RestoreFlowsTask.html#run/1","title":"Astarte.Flow.RestoreFlowsTask.run/1","type":"function"},{"doc":"","ref":"Astarte.Flow.RestoreFlowsTask.html#start_link/1","title":"Astarte.Flow.RestoreFlowsTask.start_link/1","type":"function"},{"doc":"The entrypoint for defining your web interface, such as controllers, views, channels and so on. This can be used in your application as: use Astarte.FlowWeb , :controller use Astarte.FlowWeb , :view The definitions below will be executed for every view, controller, etc, so keep them short and clean, focused on imports, uses and aliases. Do NOT define functions inside the quoted expressions below. Instead, define any helper function in modules and import those modules here.","ref":"Astarte.FlowWeb.html","title":"Astarte.FlowWeb","type":"module"},{"doc":"When used, dispatch to the appropriate controller/view/etc.","ref":"Astarte.FlowWeb.html#__using__/1","title":"Astarte.FlowWeb.__using__/1","type":"macro"},{"doc":"","ref":"Astarte.FlowWeb.html#channel/0","title":"Astarte.FlowWeb.channel/0","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.html#controller/0","title":"Astarte.FlowWeb.controller/0","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.html#router/0","title":"Astarte.FlowWeb.router/0","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.html#view/0","title":"Astarte.FlowWeb.view/0","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.BlockController.html","title":"Astarte.FlowWeb.BlockController","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.BlockController.html#create/2","title":"Astarte.FlowWeb.BlockController.create/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.BlockController.html#delete/2","title":"Astarte.FlowWeb.BlockController.delete/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.BlockController.html#index/2","title":"Astarte.FlowWeb.BlockController.index/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.BlockController.html#show/2","title":"Astarte.FlowWeb.BlockController.show/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.BlockView.html","title":"Astarte.FlowWeb.BlockView","type":"module"},{"doc":"The resource name, as an atom, for this view","ref":"Astarte.FlowWeb.BlockView.html#__resource__/0","title":"Astarte.FlowWeb.BlockView.__resource__/0","type":"function"},{"doc":"Renders the given template locally.","ref":"Astarte.FlowWeb.BlockView.html#render/2","title":"Astarte.FlowWeb.BlockView.render/2","type":"function"},{"doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template.","ref":"Astarte.FlowWeb.BlockView.html#template_not_found/2","title":"Astarte.FlowWeb.BlockView.template_not_found/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.ChangesetView.html","title":"Astarte.FlowWeb.ChangesetView","type":"module"},{"doc":"The resource name, as an atom, for this view","ref":"Astarte.FlowWeb.ChangesetView.html#__resource__/0","title":"Astarte.FlowWeb.ChangesetView.__resource__/0","type":"function"},{"doc":"Renders the given template locally.","ref":"Astarte.FlowWeb.ChangesetView.html#render/2","title":"Astarte.FlowWeb.ChangesetView.render/2","type":"function"},{"doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template.","ref":"Astarte.FlowWeb.ChangesetView.html#template_not_found/2","title":"Astarte.FlowWeb.ChangesetView.template_not_found/2","type":"function"},{"doc":"Traverses and translates changeset errors. See Ecto.Changeset.traverse_errors/2 and Astarte.FlowWeb.ErrorHelpers.translate_error/1 for more details.","ref":"Astarte.FlowWeb.ChangesetView.html#translate_errors/1","title":"Astarte.FlowWeb.ChangesetView.translate_errors/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Endpoint.html","title":"Astarte.FlowWeb.Endpoint","type":"module"},{"doc":"Callback implementation for Phoenix.Endpoint.broadcast/3 .","ref":"Astarte.FlowWeb.Endpoint.html#broadcast/3","title":"Astarte.FlowWeb.Endpoint.broadcast/3","type":"function"},{"doc":"Callback implementation for Phoenix.Endpoint.broadcast!/3 .","ref":"Astarte.FlowWeb.Endpoint.html#broadcast!/3","title":"Astarte.FlowWeb.Endpoint.broadcast!/3","type":"function"},{"doc":"Callback implementation for Phoenix.Endpoint.broadcast_from/4 .","ref":"Astarte.FlowWeb.Endpoint.html#broadcast_from/4","title":"Astarte.FlowWeb.Endpoint.broadcast_from/4","type":"function"},{"doc":"Callback implementation for Phoenix.Endpoint.broadcast_from!/4 .","ref":"Astarte.FlowWeb.Endpoint.html#broadcast_from!/4","title":"Astarte.FlowWeb.Endpoint.broadcast_from!/4","type":"function"},{"doc":"Callback implementation for Plug.call/2 .","ref":"Astarte.FlowWeb.Endpoint.html#call/2","title":"Astarte.FlowWeb.Endpoint.call/2","type":"function"},{"doc":"Returns the child specification to start the endpoint under a supervision tree.","ref":"Astarte.FlowWeb.Endpoint.html#child_spec/1","title":"Astarte.FlowWeb.Endpoint.child_spec/1","type":"function"},{"doc":"Returns the endpoint configuration for key Returns default if the key does not exist.","ref":"Astarte.FlowWeb.Endpoint.html#config/2","title":"Astarte.FlowWeb.Endpoint.config/2","type":"function"},{"doc":"Reloads the configuration given the application environment changes.","ref":"Astarte.FlowWeb.Endpoint.html#config_change/2","title":"Astarte.FlowWeb.Endpoint.config_change/2","type":"function"},{"doc":"Returns the host for the given endpoint.","ref":"Astarte.FlowWeb.Endpoint.html#host/0","title":"Astarte.FlowWeb.Endpoint.host/0","type":"function"},{"doc":"Callback implementation for Plug.init/1 .","ref":"Astarte.FlowWeb.Endpoint.html#init/1","title":"Astarte.FlowWeb.Endpoint.init/1","type":"function"},{"doc":"Callback implementation for Phoenix.Endpoint.local_broadcast/3 .","ref":"Astarte.FlowWeb.Endpoint.html#local_broadcast/3","title":"Astarte.FlowWeb.Endpoint.local_broadcast/3","type":"function"},{"doc":"Callback implementation for Phoenix.Endpoint.local_broadcast_from/4 .","ref":"Astarte.FlowWeb.Endpoint.html#local_broadcast_from/4","title":"Astarte.FlowWeb.Endpoint.local_broadcast_from/4","type":"function"},{"doc":"Generates the path information when routing to this endpoint.","ref":"Astarte.FlowWeb.Endpoint.html#path/1","title":"Astarte.FlowWeb.Endpoint.path/1","type":"function"},{"doc":"Generates the script name.","ref":"Astarte.FlowWeb.Endpoint.html#script_name/0","title":"Astarte.FlowWeb.Endpoint.script_name/0","type":"function"},{"doc":"Starts the endpoint supervision tree.","ref":"Astarte.FlowWeb.Endpoint.html#start_link/1","title":"Astarte.FlowWeb.Endpoint.start_link/1","type":"function"},{"doc":"Generates a base64-encoded cryptographic hash (sha512) to a static file in priv/static . Meant to be used for Subresource Integrity with CDNs.","ref":"Astarte.FlowWeb.Endpoint.html#static_integrity/1","title":"Astarte.FlowWeb.Endpoint.static_integrity/1","type":"function"},{"doc":"Returns a two item tuple with the first item being the static_path and the second item being the static_integrity .","ref":"Astarte.FlowWeb.Endpoint.html#static_lookup/1","title":"Astarte.FlowWeb.Endpoint.static_lookup/1","type":"function"},{"doc":"Generates a route to a static file in priv/static .","ref":"Astarte.FlowWeb.Endpoint.html#static_path/1","title":"Astarte.FlowWeb.Endpoint.static_path/1","type":"function"},{"doc":"Generates the static URL without any path information. It uses the configuration under :static_url to generate such. It falls back to :url if :static_url is not set.","ref":"Astarte.FlowWeb.Endpoint.html#static_url/0","title":"Astarte.FlowWeb.Endpoint.static_url/0","type":"function"},{"doc":"Generates the endpoint base URL but as a URI struct. It uses the configuration under :url to generate such. Useful for manipulating the URL data and passing it to URL helpers.","ref":"Astarte.FlowWeb.Endpoint.html#struct_url/0","title":"Astarte.FlowWeb.Endpoint.struct_url/0","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Endpoint.html#subscribe/2","title":"Astarte.FlowWeb.Endpoint.subscribe/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Endpoint.html#unsubscribe/1","title":"Astarte.FlowWeb.Endpoint.unsubscribe/1","type":"function"},{"doc":"Generates the endpoint base URL without any path information. It uses the configuration under :url to generate such.","ref":"Astarte.FlowWeb.Endpoint.html#url/0","title":"Astarte.FlowWeb.Endpoint.url/0","type":"function"},{"doc":"Conveniences for translating and building error messages.","ref":"Astarte.FlowWeb.ErrorHelpers.html","title":"Astarte.FlowWeb.ErrorHelpers","type":"module"},{"doc":"Translates an error message using gettext.","ref":"Astarte.FlowWeb.ErrorHelpers.html#translate_error/1","title":"Astarte.FlowWeb.ErrorHelpers.translate_error/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.ErrorView.html","title":"Astarte.FlowWeb.ErrorView","type":"module"},{"doc":"The resource name, as an atom, for this view","ref":"Astarte.FlowWeb.ErrorView.html#__resource__/0","title":"Astarte.FlowWeb.ErrorView.__resource__/0","type":"function"},{"doc":"Renders the given template locally.","ref":"Astarte.FlowWeb.ErrorView.html#render/2","title":"Astarte.FlowWeb.ErrorView.render/2","type":"function"},{"doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template.","ref":"Astarte.FlowWeb.ErrorView.html#template_not_found/2","title":"Astarte.FlowWeb.ErrorView.template_not_found/2","type":"function"},{"doc":"Translates controller action results into valid Plug.Conn responses. See Phoenix.Controller.action_fallback/1 for more details.","ref":"Astarte.FlowWeb.FallbackController.html","title":"Astarte.FlowWeb.FallbackController","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.FallbackController.html#auth_error/3","title":"Astarte.FlowWeb.FallbackController.auth_error/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.FlowController.html","title":"Astarte.FlowWeb.FlowController","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.FlowController.html#create/2","title":"Astarte.FlowWeb.FlowController.create/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.FlowController.html#delete/2","title":"Astarte.FlowWeb.FlowController.delete/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.FlowController.html#index/2","title":"Astarte.FlowWeb.FlowController.index/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.FlowController.html#show/2","title":"Astarte.FlowWeb.FlowController.show/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.FlowView.html","title":"Astarte.FlowWeb.FlowView","type":"module"},{"doc":"The resource name, as an atom, for this view","ref":"Astarte.FlowWeb.FlowView.html#__resource__/0","title":"Astarte.FlowWeb.FlowView.__resource__/0","type":"function"},{"doc":"Renders the given template locally.","ref":"Astarte.FlowWeb.FlowView.html#render/2","title":"Astarte.FlowWeb.FlowView.render/2","type":"function"},{"doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template.","ref":"Astarte.FlowWeb.FlowView.html#template_not_found/2","title":"Astarte.FlowWeb.FlowView.template_not_found/2","type":"function"},{"doc":"A module providing Internationalization with a gettext-based API. By using Gettext , your module gains a set of macros for translations, for example: import Astarte.FlowWeb.Gettext # Simple translation gettext ( &quot;Here is the string to translate&quot; ) # Plural translation ngettext ( &quot;Here is the string to translate&quot; , &quot;Here are the strings to translate&quot; , 3 ) # Domain-based translation dgettext ( &quot;errors&quot; , &quot;Here is the error message to translate&quot; ) See the Gettext Docs for detailed usage.","ref":"Astarte.FlowWeb.Gettext.html","title":"Astarte.FlowWeb.Gettext","type":"module"},{"doc":"Callback implementation for Gettext.Backend.dgettext/3 .","ref":"Astarte.FlowWeb.Gettext.html#dgettext/3","title":"Astarte.FlowWeb.Gettext.dgettext/3","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.dgettext_noop/2 .","ref":"Astarte.FlowWeb.Gettext.html#dgettext_noop/2","title":"Astarte.FlowWeb.Gettext.dgettext_noop/2","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.dngettext/5 .","ref":"Astarte.FlowWeb.Gettext.html#dngettext/5","title":"Astarte.FlowWeb.Gettext.dngettext/5","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.dngettext_noop/3 .","ref":"Astarte.FlowWeb.Gettext.html#dngettext_noop/3","title":"Astarte.FlowWeb.Gettext.dngettext_noop/3","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.dpgettext/4 .","ref":"Astarte.FlowWeb.Gettext.html#dpgettext/4","title":"Astarte.FlowWeb.Gettext.dpgettext/4","type":"macro"},{"doc":"","ref":"Astarte.FlowWeb.Gettext.html#dpgettext_noop/3","title":"Astarte.FlowWeb.Gettext.dpgettext_noop/3","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.dpngettext/6 .","ref":"Astarte.FlowWeb.Gettext.html#dpngettext/6","title":"Astarte.FlowWeb.Gettext.dpngettext/6","type":"macro"},{"doc":"","ref":"Astarte.FlowWeb.Gettext.html#dpngettext_noop/4","title":"Astarte.FlowWeb.Gettext.dpngettext_noop/4","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.gettext/2 .","ref":"Astarte.FlowWeb.Gettext.html#gettext/2","title":"Astarte.FlowWeb.Gettext.gettext/2","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.gettext_comment/1 .","ref":"Astarte.FlowWeb.Gettext.html#gettext_comment/1","title":"Astarte.FlowWeb.Gettext.gettext_comment/1","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.gettext_noop/1 .","ref":"Astarte.FlowWeb.Gettext.html#gettext_noop/1","title":"Astarte.FlowWeb.Gettext.gettext_noop/1","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.handle_missing_bindings/2 .","ref":"Astarte.FlowWeb.Gettext.html#handle_missing_bindings/2","title":"Astarte.FlowWeb.Gettext.handle_missing_bindings/2","type":"function"},{"doc":"Callback implementation for Gettext.Backend.handle_missing_plural_translation/6 .","ref":"Astarte.FlowWeb.Gettext.html#handle_missing_plural_translation/6","title":"Astarte.FlowWeb.Gettext.handle_missing_plural_translation/6","type":"function"},{"doc":"Callback implementation for Gettext.Backend.handle_missing_translation/4 .","ref":"Astarte.FlowWeb.Gettext.html#handle_missing_translation/4","title":"Astarte.FlowWeb.Gettext.handle_missing_translation/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Gettext.html#lgettext/5","title":"Astarte.FlowWeb.Gettext.lgettext/5","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Gettext.html#lngettext/7","title":"Astarte.FlowWeb.Gettext.lngettext/7","type":"function"},{"doc":"Callback implementation for Gettext.Backend.ngettext/4 .","ref":"Astarte.FlowWeb.Gettext.html#ngettext/4","title":"Astarte.FlowWeb.Gettext.ngettext/4","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.ngettext_noop/2 .","ref":"Astarte.FlowWeb.Gettext.html#ngettext_noop/2","title":"Astarte.FlowWeb.Gettext.ngettext_noop/2","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.pgettext/3 .","ref":"Astarte.FlowWeb.Gettext.html#pgettext/3","title":"Astarte.FlowWeb.Gettext.pgettext/3","type":"macro"},{"doc":"","ref":"Astarte.FlowWeb.Gettext.html#pgettext_noop/2","title":"Astarte.FlowWeb.Gettext.pgettext_noop/2","type":"macro"},{"doc":"Callback implementation for Gettext.Backend.pngettext/5 .","ref":"Astarte.FlowWeb.Gettext.html#pngettext/5","title":"Astarte.FlowWeb.Gettext.pngettext/5","type":"macro"},{"doc":"","ref":"Astarte.FlowWeb.Gettext.html#pngettext_noop/3","title":"Astarte.FlowWeb.Gettext.pngettext_noop/3","type":"macro"},{"doc":"","ref":"Astarte.FlowWeb.HealthPlug.html","title":"Astarte.FlowWeb.HealthPlug","type":"module"},{"doc":"Callback implementation for Plug.call/2 .","ref":"Astarte.FlowWeb.HealthPlug.html#call/2","title":"Astarte.FlowWeb.HealthPlug.call/2","type":"function"},{"doc":"Callback implementation for Plug.init/1 .","ref":"Astarte.FlowWeb.HealthPlug.html#init/1","title":"Astarte.FlowWeb.HealthPlug.init/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.MetricsPlug.html","title":"Astarte.FlowWeb.MetricsPlug","type":"module"},{"doc":"Callback implementation for Plug.call/2 .","ref":"Astarte.FlowWeb.MetricsPlug.html#call/2","title":"Astarte.FlowWeb.MetricsPlug.call/2","type":"function"},{"doc":"Callback implementation for Plug.init/1 .","ref":"Astarte.FlowWeb.MetricsPlug.html#init/1","title":"Astarte.FlowWeb.MetricsPlug.init/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.PipelineController.html","title":"Astarte.FlowWeb.PipelineController","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.PipelineController.html#create/2","title":"Astarte.FlowWeb.PipelineController.create/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.PipelineController.html#delete/2","title":"Astarte.FlowWeb.PipelineController.delete/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.PipelineController.html#index/2","title":"Astarte.FlowWeb.PipelineController.index/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.PipelineController.html#show/2","title":"Astarte.FlowWeb.PipelineController.show/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.PipelineView.html","title":"Astarte.FlowWeb.PipelineView","type":"module"},{"doc":"The resource name, as an atom, for this view","ref":"Astarte.FlowWeb.PipelineView.html#__resource__/0","title":"Astarte.FlowWeb.PipelineView.__resource__/0","type":"function"},{"doc":"Renders the given template locally.","ref":"Astarte.FlowWeb.PipelineView.html#render/2","title":"Astarte.FlowWeb.PipelineView.render/2","type":"function"},{"doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template.","ref":"Astarte.FlowWeb.PipelineView.html#template_not_found/2","title":"Astarte.FlowWeb.PipelineView.template_not_found/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Plug.AuthorizePath.html","title":"Astarte.FlowWeb.Plug.AuthorizePath","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.Plug.AuthorizePath.html#call/2","title":"Astarte.FlowWeb.Plug.AuthorizePath.call/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Plug.AuthorizePath.html#init/1","title":"Astarte.FlowWeb.Plug.AuthorizePath.init/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Plug.GuardianAuthorizePath.html","title":"Astarte.FlowWeb.Plug.GuardianAuthorizePath","type":"module"},{"doc":"Callback implementation for Plug.call/2 .","ref":"Astarte.FlowWeb.Plug.GuardianAuthorizePath.html#call/2","title":"Astarte.FlowWeb.Plug.GuardianAuthorizePath.call/2","type":"function"},{"doc":"Callback implementation for Plug.init/1 .","ref":"Astarte.FlowWeb.Plug.GuardianAuthorizePath.html#init/1","title":"Astarte.FlowWeb.Plug.GuardianAuthorizePath.init/1","type":"function"},{"doc":"This is a wrapper around Guardian.Plug.VerifyHeader that allows to recover the JWT public key dynamically using informations contained in the connection","ref":"Astarte.FlowWeb.Plug.VerifyHeader.html","title":"Astarte.FlowWeb.Plug.VerifyHeader","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.Plug.VerifyHeader.html#call/2","title":"Astarte.FlowWeb.Plug.VerifyHeader.call/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Plug.VerifyHeader.html#init/1","title":"Astarte.FlowWeb.Plug.VerifyHeader.init/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.html","title":"Astarte.FlowWeb.Router","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.Router.html#api/2","title":"Astarte.FlowWeb.Router.api/2","type":"function"},{"doc":"Callback invoked by Plug on every request.","ref":"Astarte.FlowWeb.Router.html#call/2","title":"Astarte.FlowWeb.Router.call/2","type":"function"},{"doc":"Callback required by Plug that initializes the router for serving web requests.","ref":"Astarte.FlowWeb.Router.html#init/1","title":"Astarte.FlowWeb.Router.init/1","type":"function"},{"doc":"Module with named helpers generated from Astarte.FlowWeb.Router.","ref":"Astarte.FlowWeb.Router.Helpers.html","title":"Astarte.FlowWeb.Router.Helpers","type":"module"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#block_path/3","title":"Astarte.FlowWeb.Router.Helpers.block_path/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#block_path/4","title":"Astarte.FlowWeb.Router.Helpers.block_path/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#block_path/5","title":"Astarte.FlowWeb.Router.Helpers.block_path/5","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#block_url/3","title":"Astarte.FlowWeb.Router.Helpers.block_url/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#block_url/4","title":"Astarte.FlowWeb.Router.Helpers.block_url/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#block_url/5","title":"Astarte.FlowWeb.Router.Helpers.block_url/5","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#flow_path/3","title":"Astarte.FlowWeb.Router.Helpers.flow_path/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#flow_path/4","title":"Astarte.FlowWeb.Router.Helpers.flow_path/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#flow_path/5","title":"Astarte.FlowWeb.Router.Helpers.flow_path/5","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#flow_url/3","title":"Astarte.FlowWeb.Router.Helpers.flow_url/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#flow_url/4","title":"Astarte.FlowWeb.Router.Helpers.flow_url/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#flow_url/5","title":"Astarte.FlowWeb.Router.Helpers.flow_url/5","type":"function"},{"doc":"Generates the path information including any necessary prefix.","ref":"Astarte.FlowWeb.Router.Helpers.html#path/2","title":"Astarte.FlowWeb.Router.Helpers.path/2","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#pipeline_path/3","title":"Astarte.FlowWeb.Router.Helpers.pipeline_path/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#pipeline_path/4","title":"Astarte.FlowWeb.Router.Helpers.pipeline_path/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#pipeline_path/5","title":"Astarte.FlowWeb.Router.Helpers.pipeline_path/5","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#pipeline_url/3","title":"Astarte.FlowWeb.Router.Helpers.pipeline_url/3","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#pipeline_url/4","title":"Astarte.FlowWeb.Router.Helpers.pipeline_url/4","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Router.Helpers.html#pipeline_url/5","title":"Astarte.FlowWeb.Router.Helpers.pipeline_url/5","type":"function"},{"doc":"Generates an integrity hash to a static asset given its file path.","ref":"Astarte.FlowWeb.Router.Helpers.html#static_integrity/2","title":"Astarte.FlowWeb.Router.Helpers.static_integrity/2","type":"function"},{"doc":"Generates path to a static asset given its file path.","ref":"Astarte.FlowWeb.Router.Helpers.html#static_path/2","title":"Astarte.FlowWeb.Router.Helpers.static_path/2","type":"function"},{"doc":"Generates url to a static asset given its file path.","ref":"Astarte.FlowWeb.Router.Helpers.html#static_url/2","title":"Astarte.FlowWeb.Router.Helpers.static_url/2","type":"function"},{"doc":"Generates the connection/endpoint base URL without any path information.","ref":"Astarte.FlowWeb.Router.Helpers.html#url/1","title":"Astarte.FlowWeb.Router.Helpers.url/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Telemetry.html","title":"Astarte.FlowWeb.Telemetry","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"Astarte.FlowWeb.Telemetry.html#child_spec/1","title":"Astarte.FlowWeb.Telemetry.child_spec/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Telemetry.html#metrics/0","title":"Astarte.FlowWeb.Telemetry.metrics/0","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.Telemetry.html#start_link/1","title":"Astarte.FlowWeb.Telemetry.start_link/1","type":"function"},{"doc":"","ref":"Astarte.FlowWeb.UserSocket.html","title":"Astarte.FlowWeb.UserSocket","type":"module"},{"doc":"Callback implementation for Phoenix.Socket.connect/3 .","ref":"Astarte.FlowWeb.UserSocket.html#connect/3","title":"Astarte.FlowWeb.UserSocket.connect/3","type":"function"},{"doc":"Callback implementation for Phoenix.Socket.id/1 .","ref":"Astarte.FlowWeb.UserSocket.html#id/1","title":"Astarte.FlowWeb.UserSocket.id/1","type":"function"},{"doc":"Astarte Flow is a data processing framework which allows you to build reusable pipelines to process, classify and analyze your data. Flow integrates seamlessly with Astarte and Kubernetes , letting you focus on your algorithms while it handles data retrieval, routing and orchestration. One of Astarte Flow key features is the ability to provide your own container as a data processing block, without having to worry about all the low level details needed to deploy it inside Kubernetes and making it receive data. By using Flow Python SDK , you just have to use the provided callbacks and functions to interact with incoming and outgoing messages in a standard format, Flow will take care of the rest. These are some of the main concepts used in Astarte Flow and covered in this guide: Messages are Flow's representation of a piece of data that is being processed. Blocks are the fundamental processing unit of Astarte Flow. Container Blocks are a special kind of block which allows you to process your data with a Docker container. Pipelines are collections of blocks providing routing logic and representing a specific computation. Flows are specific instances of a pipeline, created providing concrete values to the parametric values of a pipeline. Streams are sequences of messages sharing the same key and processes by the same Flow. The two main ways to interact with Flow are through the pipeline editor and through the REST API .","ref":"0001-overview.html","title":"Overview","type":"extras"},{"doc":"Astarte Flow main focus is messages processing.","ref":"0002-flow-messages.html","title":"Astarte Flow Messages","type":"extras"},{"doc":":key : a unicode string that identifies the stream the message belongs to. :metadata : additional message metadata as a map with string key and string value. :type : message data type (e.g. integer, real, boolean, etc...). :subtype : a string that represents the subtype, that is a mimetype for binaries. :timestamp : timestamp in microseconds from Epoch UTC. :data : the message payload.","ref":"0002-flow-messages.html#message-structure","title":"Astarte Flow Messages - Message Structure","type":"extras"},{"doc":"Messages are a convenient envelope around values, which are strongly typed. There are 6 different base types, which are the smallest building block: integer : unlimited integer numbers such as -1 , 0 and 282174488599599500573849980909 real : double precision floating point numbers. NaNs and other special values are not allowed boolean : either true or false . datetime : timestamps with microsecond precision. binary : any sequence of bytes, such as &quot;Hello&quot; , &lt;&lt;0x00, 0x01, 0xFF&gt;&gt; and &lt;&lt;&gt;&gt; string : any unicode string, such as &quot;Hello&quot; and &quot;文字列&quot; Each of the previous base types has an array counterpart, such as integer array (e.g. [1, 2, 3] ) or string array (e.g. [&quot;hello&quot;, &quot;world] ). However array of arrays are not allowed, therefore [[1, 2], [3, 4]] is invalid. Heterogeneous arrays are not supported as well, hence [1, &quot;hello&quot;, true] is invalid. Map type, with any number of keys, is supported. Keys can be any arbitrary string, while any base type or array type is supported as values (hence nested maps are not allowed, e.g. {&quot;a&quot;: {&quot;b&quot;: true}} is invalid). Astarte Flow typing system disallow any kind of recursive type. The following is a valid map: { &quot;one&quot; : 1 , &quot;sky is blue&quot; : true , &quot;green&quot; : &quot;緑&quot; , &quot;coords&quot; : [ 1.1 , 1.2 , 1.3 ] } }","ref":"0002-flow-messages.html#data-and-types","title":"Astarte Flow Messages - Data and Types","type":"extras"},{"doc":"Each message has a key, the key identifies the stream which the message belongs to. Keys can be any non empty string, Astarte Flow will take care of consistent sharding on keys.","ref":"0002-flow-messages.html#key","title":"Astarte Flow Messages - Key","type":"extras"},{"doc":"Each message has a timestamp with microsecond precision, timestamps are generally related to the event that generated the message. For instance when the message represents a sensor measurement, timestamp will likely be the measurement timestamp (since UTC Epoch ).","ref":"0002-flow-messages.html#timestamp","title":"Astarte Flow Messages - Timestamp","type":"extras"},{"doc":"Messages have a special metadata which is subtype, that is useful when type is binary. Subtype should be used to keep track of the binary mimetype (such as &quot;application/json&quot; ).","ref":"0002-flow-messages.html#subtype","title":"Astarte Flow Messages - Subtype","type":"extras"},{"doc":"Metadata is an optional map, which stores user defined metadata. Both key and values must be strings.","ref":"0002-flow-messages.html#metadata","title":"Astarte Flow Messages - Metadata","type":"extras"},{"doc":"The preferred wire-level encoding of messages is JSON, which is used for exchanging messages with containers. Message JSON encoding relies on schema key which tells the decoder how the message is serialized, future versions might use different schemas. The following is an example of a JSON encoded message, which carries binary data. { &quot;schema&quot;: &quot;astarte_flow/message/v0.1&quot;, &quot;data&quot;: &quot;AAECAA==&quot;, &quot;key&quot;: &quot;binaries_stream&quot;, &quot;metadata&quot;: {}, &quot;timestamp&quot;: 1551884045074, &quot;timestamp_us&quot;: 181, &quot;type&quot;: &quot;binary&quot;, &quot;subtype&quot;: &quot;application/octet-stream&quot; } The following message encodes a map, having a binary and a real value: { &quot;schema&quot;: &quot;astarte_flow/message/v0.1&quot;, &quot;data&quot;: { &quot;a&quot;: -1, &quot;b&quot;: &quot;Q2lhbwo=&quot; }, &quot;key&quot;: &quot;maps_stream&quot;, &quot;metadata&quot;: { &quot;hello&quot;: &quot;world&quot; }, &quot;timestamp&quot;: 1551884045074, &quot;timestamp_us&quot;: 181, &quot;type&quot;: { &quot;a&quot;: &quot;real&quot;, &quot;b&quot;: &quot;binary&quot; }, &quot;subtype&quot;: { &quot;b&quot;: &quot;text/plain&quot; } }","ref":"0002-flow-messages.html#json-encoding","title":"Astarte Flow Messages - JSON Encoding","type":"extras"},{"doc":"Astarte Flow base computation unit is a block and their purpose is consuming, producing and processing messages. Blocks are used as pipelines building blocks by chaining them together, in order to define a logical computation topology. There are 3 kinds of blocks that play different roles in a pipeline: Producer (Source): they produce messages from events coming from the outside world Consumer (Sink): they output data from Astarte Flow to the outside world Producer &amp; Consumer (Transform / Process): they transform messages Blocks Configuration Blocks behavior depends on their configuration, that can be changed by setting some properties ( e.g. to_json block has a pretty boolean property which allows deciding wether JSON output is human readable (pretty) or not).","ref":"0003-blocks.html","title":"Blocks","type":"extras"},{"doc":"Blocks configuration is validated against its JSON Schema , therefore a new block implementation requires writing a JSON Schema for it. Implementing a Block Blocks can be implemented using different technologies: As a Docker container using any language suitable for Docker (e.g. Python ), which is the best option for implementing custom complex algorithms As a chain of existing blocks (a pipeline), that is the go-to solution when a block can be implemented by just chaining blocks together As a Lua 5.2 script, that is the idea solution for small adjustments and simple data transformations, such as applying a conversion formula As an Elixir module, that is how built-in blocks are implemented","ref":"0003-blocks.html#validation","title":"Blocks - Validation","type":"extras"},{"doc":"A Pipeline is a blueprint (therefore a description) built as a chain of blocks . A pipeline can be parametric, so the same description can be made generic and applied in different scenarios that require the same computation steps (but performed with different parameters). Parameters are provided with a JSON configuration object when a pipeline is instantiated, and they can be accessed using JSON Path . Once a pipeline has been instantiated it is called a Flow , and from that moment it starts processing messages , taking up the necessary computation resources. Designing / Writing a Pipeline A pipeline can be designed using a visual editor (Pipeline Builder, which is part of Astarte Dashboard ) or written using Astarte Flow Pipeline DSL . Managing Pipelines A pipeline can be installed using Astarte Dashboard or using Astarte Flow REST API . The latter is best-suited for scripts and automations.","ref":"0004-pipelines.html","title":"Pipelines","type":"extras"},{"doc":"A Pipeline is just a blueprint, therefore it must be instantiated and all parameters must be known. If we imagine our messages as chocolate chip cookies, a Flow is the cookies production line, while a Pipeline is the description about how the cookies production line should be built. Flows consumes resources such as memory and CPU while they process messages, and they have a throughput that can be measured in messages per second. It is really important to realize that queueing theory applies here, therefore processing power and pipeline design should match message arrival rate and other requirements such as latency. Flow Configuration When a Flow is created using a parametric pipeline, a configuration specifying the parameter values should be provided. This is done using a custom JSON object which contain all the required parameters, and that will be validated using the pipeline schema. Flows Management Astarte Flow allows flows management (start, stop, inspect) using Astarte Dashboard or Astarte Flow REST API . The latter should be prefered for building custom Astarte Flow clients, scripts and automations.","ref":"0005-flows.html","title":"Flows","type":"extras"},{"doc":"A stream is a sequence of messages, with each message having the same key. Different streams might processed by the same set of blocks inside a flow , message processing might be interleaved but their relative order (inside the same stream) is kept. A practical example of the concept of streams is the sequence of messages coming from several similar sensors, which can share the same processing infrastructure but must be stored as different time series. Streams will play an important role in load balancing and automatic consistent sharding, therefore messages that belong to a stream are always processed in-order by the same set of computing resources.","ref":"0006-streams.html","title":"Streams","type":"extras"},{"doc":"Astarte Flow has its own DSL for pipeline definition. Pipe Operator The core construct behind Astarte Flow pipelines is the pipe operator | which connects two blocks. In the following example messages flowing out from block1 (the source) will be processed from block2 and they will be processes from block3 (the sink): block1 | block2 | block3 New lines are allowed (and suggested) for readabilty reasons. With Operator Most of the times blocks are not usable alone without any kind of configuration. Astarte Flow DSL defines a . operator that can be read as &quot;with&quot;. Several . can be chained together. Syntax for . operator is block.property1(value1).property2(value2) . The following example can be read as: &quot;Pipe messages from astarte_devices_source block with realm &quot;test&quot; to filter block with script &quot;return message.value &gt; 0&quot; . astarte_devices_source . realm ( &quot;test&quot; ) | filter . script ( &quot;return message.value &gt; 0&quot; ) Literals In Astarte Flow DSL literals are meant to be used with . operator.","ref":"0010-defining-a-pipeline.html","title":"Defining a Pipeline","type":"extras"},{"doc":"Base 10 integers are allowed, such as -1 , 0 and 89 .","ref":"0010-defining-a-pipeline.html#integers","title":"Defining a Pipeline - Integers","type":"extras"},{"doc":"true and false boolean values are allowed.","ref":"0010-defining-a-pipeline.html#booleans","title":"Defining a Pipeline - Booleans","type":"extras"},{"doc":"Strings are marked with &quot;&quot; , such as &quot;a string&quot; . In some situations it might be convenient using multi-line strings such as: &quot;&quot;&quot; A &quot;multi-line&quot; string &quot;&quot;&quot; Multi-line strings are convenient for Lua scripting.","ref":"0010-defining-a-pipeline.html#strings","title":"Defining a Pipeline - Strings","type":"extras"},{"doc":"JSON like objects are allowed, however there is a major difference: &quot;&quot; around keys are not required (and should not be used). { a : 1 , b : 2 , c : 3 }","ref":"0010-defining-a-pipeline.html#objects","title":"Defining a Pipeline - Objects","type":"extras"},{"doc":"JSONPath expressions such as ${ $.config.something } play a special role in Astarte Flow DSL, since they allow queries to any configuration object. Following example uses a JSON Path expressions instead of harcoding the realm name. astarte_devices_source . realm ( $ { $ . config . realm } ) Note : JSONPath expressions must always appear as bare JSONPath expressions and must not be surrounded by double quotes, even if they represent string variables. Pipeline Example astarte_devices_source . realm ( $ { $ . config . realm } ) | filter . script ( &quot;&quot;&quot; return string.find(message.key, &quot;org.astarte%-platform.genericsensors.Values&quot;) ~= nil; &quot;&quot;&quot; ) | lua_map . script ( &quot;&quot;&quot; tokens = string_utils.split(message.key, &quot;/&quot;); sensor_id = tokens[4]; new_device_id = uuid.get_v5_base64(&quot;b25aa4c6-a55b-4231-a080-a5af629d05a3&quot;, sensor_id); new_message = {}; new_message.key = config.realm .. &quot;/&quot; .. new_device_id .. &quot;/org.astarte-platform.ComputedValues/value&quot;; new_message.data = (message.data - 32) / 1.8; return new_message; &quot;&quot;&quot; ) . config ( $ { config } ) | virtual_device_pool . pairing_url ( &quot;https://example.com/pairing/v1&quot; ) . realms ( [ { realm : $ { $ . config . realm } , jwt : $ { $ . config . pairing_jwt } } ] ) . interfaces ( $ { $ . config . interfaces } ) Installing a Pipeline Pipelines can be installed using Astarte Flow REST API or using Astarte Dashboard. Running a Pipeline Pipelines are just blueprints and they must be instantiated so they can start processing messages, once instantiated they are called Flows . Pipelines must be installed in order to be instantiated, a pipeline which has not been instantiated does not consume any resource (and it does not process any message).","ref":"0010-defining-a-pipeline.html#jsonpath","title":"Defining a Pipeline - JSONPath","type":"extras"},{"doc":"The Pipeline Editor is a visual tool designed to facilitate the construction of Pipelines . It is integrated in Astarte Dashboard and automatically opens up when you head to create a new pipeline.","ref":"0020-pipeline-editor.html","title":"Pipeline Editor","type":"extras"},{"doc":"In Astarte Dashboard, go to the Pipelines section and head to create a new pipeline. You should now be able to see the visual editor, below the field to specify the pipeline's name. The visual editor itself is composed of two parts: A sidebar listing all available Blocks , grouped together by type An empty space where you can drag &amp; drop blocks, connecting them together to effectively design a pipeline Linking blocks together Each visual block has up to two handles, In and Out, that represent the block's input and output respectively. You can link two blocks together by dragging a block's Out handle to the other block's In handle. Once two blocks are linked you should see a persistent line that connects them. The number of handles a block has depends upon the block's type: Producer blocks have the Out handle Consumer blocks have the In handle Producer &amp; Consumer blocks have both the In and Out handle Thus, a valid pipeline starts with a Producer block and ends with a Consumer block. Block settings Each visual block might display a Settings icon in case some options are to be defined for the block. Clicking on the icon will open a form where such options can be specified. You can then click on the Apply settings button to save the configuration and close the form's modal. Generating the pipeline's source Once the blocks are configured and linked together, this visual representation can be transformed into a proper Pipeline's source . At the bottom right corner of the visual editor, the Generate pipeline source button serves the purpose of translating the graph into source code. If the pipeline's graph present no issues, the visual tool is hidden and you should see a form to complete the pipeline's definition, with the pipeline's source field already pre-compiled.","ref":"0020-pipeline-editor.html#overview","title":"Pipeline Editor - Overview","type":"extras"},{"doc":"There are some constraints you should be aware of while building pipelines: Multiple producer blocks are not supported, i.e. a pipeline must have exactly one initial block Each block cannot have more than one Out connection There cannot be blocks forming a loop inside a pipeline A pipeline cannot be composed of more than 50 blocks","ref":"0020-pipeline-editor.html#limitations","title":"Pipeline Editor - Limitations","type":"extras"},{"doc":"There are currently some issues that you should be aware of while building pipelines. Regarding a block's options in the visual editor: Properties with the shape of map / object are not yet supported. For instance, if you need to define HTTP headers, you can first generate the pipeline's source and then modify it by hand to add the property with HTTP headers. Properties defining a Lua script should be &lt;textarea&gt; but they are rendered as &lt;input type=&quot;text&quot;&gt; . Properties defining a Lua script do not produce a valid definition when generating the pipeline's source. You should double check that a Lua script definition starts with &quot;&quot;&quot; and ends with &quot;&quot;&quot; . Moreover: Validation of a block's options is only done when opening the modal form to configure them. If a block have options that can be configured, you should open the block's setting at least once to ensure there are no missing options that should be configured. When saving a pipeline, only a basic validation is done on its source. If you modify a pipeline's source by hand, you should double-check with the documentation to ensure that the source contains valid blocks with valid configurations.","ref":"0020-pipeline-editor.html#known-issues","title":"Pipeline Editor - Known issues","type":"extras"},{"doc":"type: producer output: any type of message Producer block that generates messages by consuming events coming from Astarte devices. This block must be combined with Astarte AMQP Triggers which allow Device events to be routed to an AMQP exchange, while the block takes care of consuming those events and transforming them to Flow messages . Note: currently only incoming_data triggers on scalar interfaces (i.e. no arrays) are supported Properties realm : the Realm which is generating the events (required, string) amqp_exchange : the exchange where the events are being published (required, string) amqp_routing_key : the routing key used to bind the consumer queue to the exchange (required, string) target_devices : a list of Device IDs. If present, only events coming from these devices will generate a message (optional, array of strings)","ref":"astarte_devices_source.html","title":"astarte_devices_source","type":"extras"},{"doc":"The Realm that is generating the events. This is also used to enforce the exchange name format (see below)","ref":"astarte_devices_source.html#realm","title":"astarte_devices_source - realm","type":"extras"},{"doc":"The exchange where the events are being published. This must match the exchange that was used while setting up the AMQP trigger, as this block will bind a queue to that exchange (possibly using the configured amqp_routing_key ). This exchange name must follow the same restrictions that are present in Astarte triggers, namely it must match this regular expression ^ astarte_events_ $ realm_ [ a - zA - Z0 - 9 _ \\ . \\ : ] + $ where $realm must be substituted with the provided realm .","ref":"astarte_devices_source.html#amqp_exchange","title":"astarte_devices_source - amqp_exchange","type":"extras"},{"doc":"The routing key used to bind the queue to the amqp_exchange . This must match the amqp_routing_key used in the AMQP trigger.","ref":"astarte_devices_source.html#amqp_routing_key","title":"astarte_devices_source - amqp_routing_key","type":"extras"},{"doc":"A list of target Device IDs (e.g. [&quot;BWh_mWEATIumVX8asPgxag&quot;, &quot;A4QR-S9FTrahKiJihYAetA&quot;] ). If it's provided, only events coming from the target devices will be considered and generate messages, all the others will be discarded. Keep in mind that filtering at this level will still generate the events on the Astarte side and publish them on RabbitMQ, so if it's possible it's better filtering at the trigger level instead, since Astarte supports specifying a Device ID or a group when creating a trigger. Output message Each consumed event will produce a Flow Message with the fields constructed in the following way: key : the key format will be realm/device_id/interface/path . For example, an event coming from the device with Device ID EA8lpOrkR8OJ-bp9dSVYQA in the test realm on the org.astarte-platform.genericsensors.Values interface with /mysensor/value path will produce a message with key test/EA8lpOrkR8OJ-bp9dSVYQA/org.astarte-platform.genericsensors.Values/mysensor/value data : the data sent from the Device. If a device sends 42.3 on the above mentioned interface, data will contain 42.3 . type : the type of the data. Currently this is not explicitly sent inside the event, so the type is deduced using an heuristic approach. This must be handled with care especially with numeric types, where there can be some instances where a double interface generates messages with integer type. timestamp : contains the timestamp (in microseconds) of the event. If the source interface supports explicit_timestamp , the timestamp is the one explicitly sent from the device, otherwise it's the reception timestamp. Examples The following example uses astarte_devices_source block to generate messages coming from the test Realm on the org.astarte-platform.genericsensors.Values interface. astarte_devices_source . realm ( &quot;test&quot; ) . amqp_exchange ( &quot;astarte_events_test_1&quot; ) [ ... ] To make the example work, the following trigger must be installed in Astarte in the test Realm: { &quot;name&quot; : &quot;example_trigger&quot; , &quot;action&quot; : { &quot;amqp_exchange&quot; : &quot;astarte_events_test_1&quot; , &quot;amqp_message_expiration_ms&quot; : 10000 , &quot;amqp_message_persistent&quot; : false } , &quot;simple_triggers&quot; : [ { &quot;type&quot; : &quot;data_trigger&quot; , &quot;on&quot; : &quot;incoming_data&quot; , &quot;interface_name&quot; : &quot;org.astarte-platform.genericsensors.Values&quot; , &quot;interface_major&quot; : 1 , &quot;match_path&quot; : &quot;/*&quot; } ] }","ref":"astarte_devices_source.html#target_devices","title":"astarte_devices_source - target_devices","type":"extras"},{"doc":"This block API will likely change in future versions. This is a special block which allows to offload computation to a Docker container . Messages are sent and received to/from the container via AMQP . The block will manage the creation of the Container in a Kubernetes cluster using the Astarte Kubernetes Operator . Containers allow implementing and deploying algorithms with a language-agnostic approach. However a Python SDK is available as a replacement to AMQP connection and JSON SerDes code. Most of the times containers can be avoided and simple messages transformation and filtering can be achieved using Lua 5.2 scripting blocks. Properties image : Docker container image (required, string) type : Container type, either &quot;producer&quot; , &quot;consumer&quot; or &quot;producer_consumer&quot; (required) image_pull_secrets : The secrets used to pull images from private registries (optional, array of strings)","ref":"container.html","title":"container","type":"extras"},{"doc":"Docker container image.","ref":"container.html#image","title":"container - image","type":"extras"},{"doc":"This block property is going to be removed in favor of implicit configuration. According to container type a container is used as an AMQP producer, cosumer or as a middle processing block.","ref":"container.html#type","title":"container - type","type":"extras"},{"doc":"A list of names of Kubernetes secrets that will be used to pull the image. This is required only if the image is pulled from a private registry. The secrets must be already existing and must live in the same namespace where Astarte Flow is deployed. For more information on creating them, please read the relevant Kubernetes documentation Accepted Input Messages Input messages are consumed only from consumer and producer_consumer containers. For those types of containers accepted input messages type and format depends on their implementation. Output message An output message is produced only from producer and producer_consumer containers. For those types of containers the output message format depends on their implementation. Examples The following example uses a container (pulled from &quot;example/test&quot; ) and declares it as producer and consumer, wich consumes messages produced by any_producer_block and feeds into any_consumer_block: any_producer_block | container . image ( &quot;example/test&quot; ) . type ( &quot;producer_consumer&quot; ) | any_consumer_block","ref":"container.html#image_pull_secrets","title":"container - image_pull_secrets","type":"extras"},{"doc":"type: producer_consumer input: any kind of message output: same message type as input This is a producer and consumer block that filters messages that get rejected by the filter script. This block supports Lua 5.2 scripts ( luerl scripting engine is used under the hood). The incoming message will be provided to the script as message . Properties script : The Lua script used to filter incoming messages. (required, string)","ref":"filter.html","title":"filter","type":"extras"},{"doc":"The Lua script that will determine if the message has to be discarded or allowed through. The script must return boolean value. When the returned value is true , the input massage passes through the filter to the next block in the pipeline. On the other hand, when the returning value is false , the message is dropped. If the return value is invalid or if an error occurs, the message is also dropped. An example script would be &quot;&quot;&quot; return message.data &gt; 0; &quot;&quot;&quot; If the message data is greater than zero, the returned value will be true allowing the message to preceed onward. See also luerl documentation . Examples The following example uses filter to drop any message that does not contain test as message key [ ... ] | filter . script ( &quot;&quot;&quot; return string.find(message.key, &quot;test&quot;) ~= nil; &quot;&quot;&quot; ) [ ... ]","ref":"filter.html#script","title":"filter - script","type":"extras"},{"doc":"type: consumer input: binary messages This is a consumer block that takes data from an incoming message and makes a POST request to the configured URL. This block supports only incoming messages with type binary , so serialization of different message types must be handled in a preceding block. For the time being, the delivery is best-effort (i.e. if a message is not delivered, it is discarded). Properties url : The URL of the HTTP request. (required, string) headers : Http request headers. (optional, object with string values) ignore_ssl_errors : If true , ignore SSL errors that happen while performing the request. (optional, boolean)","ref":"http_sink.html","title":"http_sink","type":"extras"},{"doc":"The HTTP request URL such as &quot;http://www.example.com/test&quot; .","ref":"http_sink.html#url","title":"http_sink - url","type":"extras"},{"doc":"An optional object with additional headers such as {authorization: &quot;Bearer &lt;token&gt;&quot;} . Accepted input message The HTTP request built by the http_sink can be customized by the input message with the following properties: data : the body of the request. type : is always binary . subtype : if present, it will be the value of the content-type HTTP header. Examples The following example uses http_sink block to send HTTP POST requests to http://www.example.com/test whenever a valid message is received. [ ... ] | http_sink . url ( &quot;http://www.example.com/test&quot; )","ref":"http_sink.html#headers","title":"http_sink - headers","type":"extras"},{"doc":"type: producer output: binary messages This is a producer block that generates messages by polling HTTP URLs with a GET request. It works by specifying a base_url and a list of target_paths to perform requests on. HttpSource will perform GET requests in a round robin fashion on all target_paths , waiting polling_interval_ms between two consecutive requests. Properties base_url : Target base URL. (required, string) target_paths : Relative paths. (required, string array) polling_interval_ms : Polling interval. (required, integer) headers : Http request headers. (optional, object with string values)","ref":"http_source.html","title":"http_source","type":"extras"},{"doc":"Target base URL such as &quot;http://www.example.com&quot; .","ref":"http_source.html#base_url","title":"http_source - base_url","type":"extras"},{"doc":"Relative paths to the base_url as a string array such as [&quot;/first.json&quot;, &quot;/second.json&quot;] .","ref":"http_source.html#target_paths","title":"http_source - target_paths","type":"extras"},{"doc":"The time between two consecutive polling requests, expressed in milliseconds (e.g. 5000 for a 5 seconds interval).","ref":"http_source.html#polling_interval_ms","title":"http_source - polling_interval_ms","type":"extras"},{"doc":"An optional object with additional headers such as {authorization: &quot;Bearer &lt;token&gt;&quot;} . Output message If the request succeeds, http_source produces a message containing these fields: key : contains the target_path of the request data : contains the body of the response type : is always binary subtype : is populated with the contents of the content-type HTTP header, defaulting to &quot;application/octet-stream&quot; if it's not found. metadata : contains the &quot;base_url&quot; key with base_url as value. Moreover, it contains all the HTTP headers contained in the response with their keys prefixed with &quot;Astarte.Flow.HttpSource.&quot; . timestamp : contains the timestamp (in microseconds) the response was received. If the request can't be performed or an error status ( &gt;= 400 ) is returned, no message is produced. Examples The following example uses http_source block for polling http://www.example.com/first.json and http://www.example.com/second.json every 5000 milliseconds (with a round robin policy on target paths /first.json and /second.json ). http_source . base_url ( &quot;http://www.example.com&quot; ) . target_paths ( [ &quot;/first.json&quot; , &quot;/second.json&quot; ] ) . polling_interval_ms ( 5000 )","ref":"http_source.html#headers","title":"http_source - headers","type":"extras"},{"doc":"This block API will likely change in future versions. type: producer_consumer accepted input: binary messages (in JSON format, with &quot;application/json&quot; subtype) output: message with the structure described by the template Transforms the incoming JSON message using the configured JSON template which makes use of JSONPath to extract data from the incoming message. Properties template : JSONPath template. (required, string)","ref":"json_path_map.html","title":"json_path_map","type":"extras"},{"doc":"output message template. It must be a valid JSON that makes use of JSONPath. Output message If the template rendering succeeds, json_path_map produces a message as described by template . Examples Extracts data from JSON using JSONPath expressions, and it populates a map having keys a , b , c : [ ... ] | json_path_template . template ( &quot;&quot; &quot; { &quot; data &quot;: { &quot; a &quot;: &quot; { { $ . data . data [ 0 ] . values [ ?( @ . name == \\ &quot;a \\&quot; )].value}}&quot; , &quot;b&quot; : &quot;{{$.data.data[0].values[?(@.name == \\&quot; b \\&quot; )].value}}&quot; , &quot;c&quot; : &quot;{{$.data.data[0].values[?(@.name == \\&quot; c \\&quot; )].value}}&quot; } , &quot;type&quot; : { &quot;a&quot; : &quot;real&quot; , &quot;b&quot; : &quot;real&quot; , &quot;c&quot; : &quot;real&quot; } } [ ... ]","ref":"json_path_map.html#template","title":"json_path_map - template","type":"extras"},{"doc":"type: producer_consumer accepted input: any kind of message output: transformed input message This is a producer and consumer block that takes an incoming message and it transforms it using the given Lua script. This block supports Lua 5.2 scripts ( luerl scripting engine is used under the hood). The incoming message will be provided to the script as message . This block name is not related to the map abstract data type and it should be not confused with it, instead it is related to the function (our script) application to a sequence of items (the messages). Properties script : Lua script. (required, string) config : Lua script configuration object. (optional, object)","ref":"lua_map.html","title":"lua_map","type":"extras"},{"doc":"A Lua Lua 5.2 script. The most simple script is &quot;return message;&quot; which returns an unmodified message. See also luerl documentation .","ref":"lua_map.html#script","title":"lua_map - script","type":"extras"},{"doc":"Any object. Config parameter is meant as a method to provide parameters to the Lua script, without hard-coding them. It can be accessed using config . Output message An input message transformation which depends on the script implementation. Missing message attributes are taken from the input message, therefore some fields are kept unchanged. Examples The following example uses lua_map block for Fahrenheit to Celsius degrees conversion. A key prefix is provided through config object and prepended to the string &quot;/celsius&quot; . All other existing message attributes are taken as-is from the input message. [ ... ] | lua_map . script ( &quot;&quot;&quot; new_message = {}; new_message.key = config.prefix .. &quot;/celsius&quot;; new_message.data = (message.data - 32) / 1.8; return new_message; &quot;&quot;&quot; ) . config ( $ { config } ) [ ... ]","ref":"lua_map.html#config","title":"lua_map - config","type":"extras"},{"doc":"type: producer output: integer, float or boolean messages This is a producer block that generates messages by polling a Modbus device over TCP. It works by specifying a host (optionally with a port ), a slave_id and a list of targets to be polled. Data read from registers is converted to well defined formats before generating a Flow Message. Note : currently polling_interval_ms must be the same for all targets. This limitation will be removed in a future release. Properties host : The IP adress of the Modbus device. (required, string) slave_id : The Modbus slave id of the target. (required, integer) targets : The array of targets to be polled. (required, array of objects) port : The TCP port of the target Modbus device, defaults to 502. (optional, integer)","ref":"modbus_tcp_source.html","title":"modbus_tcp_source","type":"extras"},{"doc":"A string representing an IP address to reach the Modbus device (e.g. &quot;192.168.1.2&quot; ).","ref":"modbus_tcp_source.html#host","title":"modbus_tcp_source - host","type":"extras"},{"doc":"The TCP port for the Modbus connection, defaults to 502 (the standard Modbus TCP port).","ref":"modbus_tcp_source.html#port","title":"modbus_tcp_source - port","type":"extras"},{"doc":"The slave id of the target Modbus device. This should be an integer between 1 and 247 .","ref":"modbus_tcp_source.html#slave_id","title":"modbus_tcp_source - slave_id","type":"extras"},{"doc":"An array of objects representing the targets. Each of these objects should have these keys: name : The name of the target. This will be used as key in the generated messages. (required, string) base_address : The Modbus address of the target. One or more registers starting from this address will be read when polling this target, depending on the format . (required, integer) format : The format of the data. Must be one of these strings: &quot;int16&quot; , &quot;uint16&quot; , &quot;float32be&quot; , &quot;float32le&quot; , &quot;boolean&quot; . The format will also determine how many registers are read for this target. (required, string) modbus_type : The modbus type of the target register. Must be one of these strings: &quot;coil&quot; , &quot;discrete_input&quot; , &quot;input_register&quot; , &quot;holding_register&quot; . (required, string) polling_interval_ms : The interval between to consecutive polling requests, expressed in milliseconds. Caveat : right now all targets must have the same polling interval, this limitation will be removed in a future release. (required, integer) static_metadata : A string -&gt; string object of metadata that will be added as metadata to all messages produced for this target. Output message If the polling succeeds, for each target modbus_tcp_source produces a message containing these fields: key : contains the name of the target data : contains the data converted with the chosen format type : depends on the chosen format metadata : contains the static_metadata of the target, if present timestamp contains the timestamp (in microseconds) the response was received. Examples The following example uses modbus_tcp_source to poll every 30 seconds a Modbus device at IP 192.168.1.42 at port 2000 , with a slave id value of 3 . The only target is a voltage value stored as float with a little endian format in the holding registers 42 and 43 . modbus_tcp_source . host ( &quot;192.168.1.42&quot; ) . port ( 2000 ) . slave_id ( 3 ) . targets ( [ { base_address : 42 , name : &quot;sensor-V_RMS&quot; , format : &quot;float32le&quot; , static_metadata : { units : &quot;V&quot; } polling_interval_ms : 30000 , modbus_type : &quot;holding_register&quot; } ] ) | [ ... ]","ref":"modbus_tcp_source.html#targets","title":"modbus_tcp_source - targets","type":"extras"},{"doc":"type: consumer input: binary messages This is a consumer block that takes data from an incoming message and publishes it using an MQTT connection. This block supports only incoming messages with type binary , so serialization of different message types must be handled in a preceding block. This block has been implemented using the Elixir tortoise MQTT client application . Properties broker_url : The URL of the broker the source will connect to. (required, string) client_id : The client id used to connect. Defaults to a random string. (optional, string) ignore_ssl_errors : If true, accept invalid certificates (e.g. self-signed) when using SSL. (optional, boolean, default: false ) username : Username used to authenticate to the broker. (optional, string) password : Password used to authenticate to the broker. (optional, string) ca_cert_pem : PEM encoded CA certificate. (optional, string) client_cert_pem : PEM encoded client certificate, used for mutual SSL authentication. (optional, string) private_key_pem : PEM encoded private key, used for mutual SSL authentication. (optional, string) qos : The QoS used when publishing (optional, integer, default: 0 )","ref":"mqtt_sink.html","title":"mqtt_sink","type":"extras"},{"doc":"The URL of the broker the source will connect to. The transport will be deduced by the URL: if mqtts:// is used, SSL transport will be used, if mqtt:// is used, TCP transport will be used.","ref":"mqtt_sink.html#broker_url","title":"mqtt_sink - broker_url","type":"extras"},{"doc":"The client id used to connect. Defaults to a random string.","ref":"mqtt_sink.html#client_id","title":"mqtt_sink - client_id","type":"extras"},{"doc":"If true, accept invalid certificates (e.g. self-signed ) when using SSL.","ref":"mqtt_sink.html#ignore_ssl_errors","title":"mqtt_sink - ignore_ssl_errors","type":"extras"},{"doc":"Username used to authenticate to the broker.","ref":"mqtt_sink.html#username","title":"mqtt_sink - username","type":"extras"},{"doc":"Password used to authenticate to the broker.","ref":"mqtt_sink.html#password","title":"mqtt_sink - password","type":"extras"},{"doc":"A PEM encoded CA certificate. If not provided, the default CA trust store provided by :certifi will be used.","ref":"mqtt_sink.html#ca_cert_pem","title":"mqtt_sink - ca_cert_pem","type":"extras"},{"doc":"A PEM encoded client certificate, used for mutual SSL authentication. If this is provided, also private_key_pem must be provided.","ref":"mqtt_sink.html#client_cert_pem","title":"mqtt_sink - client_cert_pem","type":"extras"},{"doc":"A PEM encoded private key, used for mutual SSL authentication. If this is provided, also client_cert_pem must be provided.","ref":"mqtt_sink.html#private_key_pem","title":"mqtt_sink - private_key_pem","type":"extras"},{"doc":"The MQTT QoS used when publishing. Defaults to 0 , possible valid values are 0 , 1 or 2 . Accepted input message This block supports only messages with a binary type. Serialization must be explicitly handled in another block. Messages with a different type are discarded by the block. The message fields are used as follows: key becomes the MQTT topic for the published message data is used as message payload type must always be binary , otherwise the message is discarded Examples This example uses the mqtt_sink block to connect to an MQTT broker with host example.com on port 8883 and publish incoming messages with QoS 1 [ ... ] | mqtt_sink . broker_url ( &quot;mqtts://example.com:8883&quot; ) . qos ( 1 )","ref":"mqtt_sink.html#qos","title":"mqtt_sink - qos","type":"extras"},{"doc":"type: producer output: a message each time an MQTT message is received An Astarte Flow source that produces data from an MQTT connection. This block has been implemented using the Elixir tortoise MQTT client application . Properties broker_url : The URL of the broker the source will connect to. (required, string) subscriptions : A non-empty list of topic filters to subscribe to. (required, string array) client_id : The client id used to connect. Defaults to a random string. (optional, string) ignore_ssl_errors : If true, accept invalid certificates (e.g. self-signed) when using SSL. (optional, boolean, default: false) username : Username used to authenticate to the broker. (optional, string) password : Password used to authenticate to the broker. (optional, string) ca_cert_pem : PEM encoded CA certificate. (optional, string) client_cert_pem : PEM encoded client certificate, used for mutual SSL authentication. (optional, string) private_key_pem : PEM encoded private key, used for mutual SSL authentication. (optional, string) subtype : A MIME type that will be put as subtype in the generated Messages. Defaults to application/octet-stream .","ref":"mqtt_source.html","title":"mqtt_source","type":"extras"},{"doc":"The URL of the broker the source will connect to. The transport will be deduced by the URL: if mqtts:// is used, SSL transport will be used, if mqtt:// is used, TCP transport will be used.","ref":"mqtt_source.html#broker_url","title":"mqtt_source - broker_url","type":"extras"},{"doc":"A non-empty list of topic filters to subscribe to.","ref":"mqtt_source.html#subscriptions","title":"mqtt_source - subscriptions","type":"extras"},{"doc":"The client id used to connect. Defaults to a random string.","ref":"mqtt_source.html#client_id","title":"mqtt_source - client_id","type":"extras"},{"doc":"If true, accept invalid certificates (e.g. self-signed ) when using SSL.","ref":"mqtt_source.html#ignore_ssl_errors","title":"mqtt_source - ignore_ssl_errors","type":"extras"},{"doc":"Username used to authenticate to the broker.","ref":"mqtt_source.html#username","title":"mqtt_source - username","type":"extras"},{"doc":"Password used to authenticate to the broker.","ref":"mqtt_source.html#password","title":"mqtt_source - password","type":"extras"},{"doc":"A PEM encoded CA certificate. If not provided, the default CA trust store provided by :certifi will be used.","ref":"mqtt_source.html#ca_cert_pem","title":"mqtt_source - ca_cert_pem","type":"extras"},{"doc":"A PEM encoded client certificate, used for mutual SSL authentication. If this is provided, also private_key_pem must be provided.","ref":"mqtt_source.html#client_cert_pem","title":"mqtt_source - client_cert_pem","type":"extras"},{"doc":"A PEM encoded private key, used for mutual SSL authentication. If this is provided, also client_cert_pem must be provided.","ref":"mqtt_source.html#private_key_pem","title":"mqtt_source - private_key_pem","type":"extras"},{"doc":"A MIME type that will be put as subtype in the generated Messages. Defaults to application/octet-stream . Output message key : contains the MQTT topic on which the message was received data : contains the payload of the message type : is always binary subtype : is always &quot;application/octet-stream&quot; but can be configured with the subtype option metadata : contains the Astarte.Flow.Blocks.MqttSource.broker_url key with the broker url as value. timestamp : contains the timestamp (in microseconds) the response was received. Examples The following example uses the mqtt_source block to connect to www.example.com MQTT broker and to subcribe to # topic. mqtt_source . broker_url ( &quot;mqtts://www.example.com/&quot; ) . subscriptions ( [ &quot;#&quot; ] ) [ ... ]","ref":"mqtt_source.html#subtype","title":"mqtt_source - subtype","type":"extras"},{"doc":"type: producer output: either integer, real or boolean messages Producer block that generates random messages of a specific type key and type. Properties key : A unicode string that will be used as key in the generated messages. (required, string) type The type of data that will be generated. Supported types are integer , real and boolean . (required, string) delay_ms : If present, the block will wait delay_ms before emitting a new sample. (optional, integer) When type is &quot;integer&quot; min : The minimum generated value, default is 0. (optional, integer) max : The maximum generated value, default is 100. (optional, integer) When type is &quot;real&quot; min : The minimum generated value, default is 0. (optional, real) max : The maximum generated value, default is 1. (optional, real) When type is &quot;boolean&quot; p : The probability of the generator returning true . Defaults to 0.5 The value must be &gt;= 0 and &lt;= 1 . (optional, real)","ref":"random_source.html","title":"random_source","type":"extras"},{"doc":"The key to be used in generated messages. (e.g. &quot;my_example_key&quot; ).","ref":"random_source.html#key","title":"random_source - key","type":"extras"},{"doc":"The type of the data contained in generated messages (e.g. &quot;integer&quot; ).","ref":"random_source.html#type","title":"random_source - type","type":"extras"},{"doc":"The minimum generated value (e.g. 0 ). Only available when type is integer or real .","ref":"random_source.html#min","title":"random_source - min","type":"extras"},{"doc":"The maximum generated value (e.g. 100 ). Only available when type is integer or real .","ref":"random_source.html#max","title":"random_source - max","type":"extras"},{"doc":"The probability of the generator returning true (e.g. 0.5 ). Only available when type is boolean","ref":"random_source.html#p","title":"random_source - p","type":"extras"},{"doc":"The delay between generated messages in milliseconds. For example use 5000 for 5 seconds. Output message key : contains the key specified as parameter. data : contains the generated value. type : the type specified as parameter. timestamp : contains the timestamp (in microseconds) in which the message was generated. Examples The following example uses random_source block to generate messages that emulate a dice throw every 10000 milliseconds (10 seconds). random_source . type ( &quot;integer&quot; ) . min ( 1 ) . max ( 6 ) . delay_ms ( 10000 ) [ ... ]","ref":"random_source.html#delay_ms","title":"random_source - delay_ms","type":"extras"},{"doc":"type: producer_consumer accepted input: any kind of message output: any kind of message (order is changed) This block is a stateful realtime block, which reorders an out of order sequence of messages, and optionally removes any duplicate message. Properties window_size_ms : Window size in milliseconds. (required, integer) deduplicate : Duplicated messages are discarded when true. (optional, boolean, default: false)","ref":"sort.html","title":"sort","type":"extras"},{"doc":"The amount of time a message is kept for reorder and deduplicate operations. This block always introduces a lag of window_size_ms milliseconds, so the window size should be carefully choosen.","ref":"sort.html#window_size_ms","title":"sort - window_size_ms","type":"extras"},{"doc":"When this option is true messages are deduplicated. Two messages are duplicate when they have same timestamp and value (any other message attribute is ignored) and they are both inside the same sliding window. Output message No transformation is performed on messages, however some messages taken from input are discarded or reordered. Examples The following example uses sort to deduplicate messages that might be duplicated due to source or transport peculiarities: [ ... ] | sort . window_size_ms ( 2000 ) . deduplicate ( true ) [ ... ]","ref":"sort.html#deduplicate","title":"sort - deduplicate","type":"extras"},{"doc":"This block API will likely change in future versions, see also GH issue #108 . type: producer_consumer accepted input: a map message having n keys output: n messages with different message keys This block breaks a map message into several messages, one for each map item. Properties key_action : Input map and output message key handling policy. (optional, string, default: &quot;replace&quot; ) delimiter : Key delimiter string. (optional, string, default: &quot;&quot; ) fallback_action : Unsplittable messages policy. (optional, string, default: &quot;pass_through&quot; ) fallback_key : Message key used when &quot;replace_key&quot; &quot;fallback_action&quot; is used. (optional, string)","ref":"split_map.html","title":"split_map","type":"extras"},{"doc":"Output message key building policy, it can be either one of the following: &quot;none&quot; : output message key is input message key (no changes) &quot;replace&quot; : output message key is replaced with keys used in input message map. &quot;append&quot; : input message map key is appended to the input message key &quot;prepend&quot; : input message map key is prepended to the input message key Let's assume the input message looks like the following: { key : &quot;inputkey&quot; data : { one : 1 , truthy : true , hello : &quot;world&quot; } } When using &quot;none&quot; the following 3 messages will be produced: { key: &quot;inputkey&quot;, data: 1, type: integer } { key: &quot;inputkey&quot;, data: true, type: boolean } { key: &quot;inputkey&quot;, data: &quot;world&quot;, type: string } When using &quot;replace&quot; the following 3 messages will be produced: { key: &quot;one&quot;, data: 1, type: integer } { key: &quot;truthy&quot;, data: true, type: boolean } { key: &quot;hello&quot;, data: &quot;world&quot;, type: string } When using &quot;append&quot; the following 3 messages will be produced: { key: &quot;inputkeyone&quot;, data: 1, type: integer } { key: &quot;inputkeytruthy&quot;, data: true, type: boolean } { key: &quot;inputkeyhello&quot;, data: &quot;world&quot;, type: string } When using &quot;prepend&quot; the following 3 messages will be produced: { key: &quot;oneinputkey&quot;, data: 1, type: integer } { key: &quot;truthyinputkey&quot;, data: true, type: boolean } { key: &quot;helloinputkey&quot;, data: &quot;world&quot;, type: string }","ref":"split_map.html#key_action","title":"split_map - key_action","type":"extras"},{"doc":"String delimiter that is used when key_action is set to &quot;append&quot; or &quot;prepend&quot; , which is used to separate the input message key and the appended/prepended map key.","ref":"split_map.html#delimiter","title":"split_map - delimiter","type":"extras"},{"doc":"Fallback action is used when input message has no map type. The following fallback actions are available: &quot;discard&quot; : input message is always discarded when it cannot be splitted &quot;replace_key&quot; : input message is kept but key is replaced with specified replace key &quot;pass_through&quot;: input message is passed through without any change ## fallback_key fallback_key is used when &quot;replace_key&quot; &quot;fallback_action&quot; is used. # Output message For each message having a map with n keys, n messages are produced. # Examples The following example uses map_split` to split messages having type map into messages that make use of base or array types, the output message key is built by appending the key of each map item to the input message key. [...] | map_split .key_action(&quot;append&quot;) .delimiter(&quot;/&quot;) [...]","ref":"split_map.html#fallback_action","title":"split_map - fallback_action","type":"extras"},{"doc":"type: producer_consumer input: any message output: binary messages This is a producer and consumer block that takes data from incoming message and produces a message having a JSON serialized payload. Properties pretty : serialize the output to pretty format that is easier to read for humans. (optional, boolean) template : a JSONTemplate template. (optional, object)","ref":"to_json.html","title":"to_json","type":"extras"},{"doc":"Specifies if the JSON binary should be pretty formatted.","ref":"to_json.html#pretty","title":"to_json - pretty","type":"extras"},{"doc":"Given {key: &quot;key&quot;, data: 42} as input message, the following template renders to {&quot;thekey&quot;: &quot;key&quot;, &quot;thevalue&quot;: 42} : . template ( { thekey : &quot;{{ message.key }}&quot; , thevalue : &quot;{{{ message.data }}}&quot; } ) Output message key : contains the same key specified in the input message. data : the incoming data formatted as a JSON binary type : is always binary subtype : is always application/json timestamp : the same timestamp specified in the input message. Examples The following example uses to_json block to format incoming messages to human readable JSON binary before letting them through. [ ... ] | to_json . pretty ( true ) [ ... ]","ref":"to_json.html#template","title":"to_json - template","type":"extras"},{"doc":"type: producer_consumer input: any message output: any message This is a producer and consumer block that modifies the metadata of incoming Message s. Properties metadata - The metadata configuration object. (required, object with string keys and string or null values)","ref":"update_metadata.html","title":"update_metadata","type":"extras"},{"doc":"This object defines how this block will change the metadata of incoming messages. All keys present in the object are either inserted or updated in the Message metadata, with the only exception that if a key has a value of null , it will be removed from metadata . All other metadata keys are not touched by this block. Output message The only modified field in the message is metadata , according to the rules specified above. Examples The following example uses update_metadata block to add/update the &quot;foo&quot; key in metadata to have the &quot;bar&quot; value, and to remove the &quot;baz&quot; metadata key. [ ... ] | update_metadata . metadata ( { foo : &quot;bar&quot; , baz : null } ) [ ... ]","ref":"update_metadata.html#metadata","title":"update_metadata - metadata","type":"extras"},{"doc":"type: consumer input: any kind of message conforming to the input format This is a consumer block that sends incoming messages to Astarte, acting as one or more virtual devices. Information about Device ID, interfaces and paths are deduced from the message key, so it's important that the key conforms to the supported format . You can use a lua_map block to add the appropriate key to your message. Please refer to Astarte documentation to more information about Astarte concepts like Device IDs, Interfaces etc.","ref":"virtual_device_pool.html","title":"virtual_device_pool","type":"extras"},{"doc":"The block has two different behaviours regarding target devices, depending on its configuration: static and dynamic. With static devices, the set of target devices is known beforehand and all devices have to registered manually before using them inside Astarte Flow. Every device can have a different set of interfaces when using a static device list. Using dynamic devices the list of devices is built dynamically: every time the block sees a new Device ID, it registers the device using Pairing API, saves its credentials_secret in the storage and starts publishing as the device. To do so, a Pairing JWT will have to be provided to the block. When using dynamic devices, all devices will share the same set of interfaces. Properties","ref":"virtual_device_pool.html#target-devices","title":"virtual_device_pool - Target devices","type":"extras"},{"doc":"pairing_url : Astarte Pairing API base URL. (required, string) target_devices : An object containing all the information about target devices. (required, object)","ref":"virtual_device_pool.html#static-devices","title":"virtual_device_pool - Static devices","type":"extras"},{"doc":"Target Astarte Pairing API URL. This is usually you base Astarte URL with a /pairing suffix (e.g. &quot;http://astarte.example.com/pairing&quot; ).","ref":"virtual_device_pool.html#pairing_url","title":"virtual_device_pool - pairing_url","type":"extras"},{"doc":"An object used to configure the target devices. The object must contain these keys: realm : the target Realm for the device (required, string) device_id : the Device ID of the target device (required, string) credentials_secret : the credentials_secret of the target device (required, string) interfaces : the interfaces supported by the target device. Note that this should be an array of objects, the whole interface definition must be present for every interface. Right now only datastream interfaces are supported. (requires, array of objects) This is an example of a target_devices object: { realm : &quot;test&quot; , device_id : &quot;EA8lpOrkR8OJ-bp9dSVYQA&quot; , credentials_secret : &quot;N0hUYzmGzpK2SdN8FLoFtw==&quot; , interfaces : [ { interface_name : &quot;org.astarte-platform.genericsensors.Values&quot; , version_major : 1 , version_minor : 0 , type : &quot;datastream&quot; , ownership : &quot;device&quot; , description : &quot;Generic sensors sampled data.&quot; , mappings : [ { endpoint : &quot;/%{sensor_id}/value&quot; , type : &quot;double&quot; , explicit_timestamp : true , description : &quot;Sampled real value.&quot; , doc : &quot;Datastream of sampled real values.&quot; } ] } ] }","ref":"virtual_device_pool.html#target_devices","title":"virtual_device_pool - target_devices","type":"extras"},{"doc":"pairing_url : Astarte Pairing API base URL. (required, string) realms : An object containing realms information. (required, object) interfaces : the interfaces supported by the target devices. Note that this should be an array of objects, the whole interface definition must be present for every interface (required, array of objects).","ref":"virtual_device_pool.html#dynamic-devices","title":"virtual_device_pool - Dynamic devices","type":"extras"},{"doc":"Target Astarte Pairing API URL. This is usually you base Astarte URL with a /pairing suffix (e.g. &quot;http://astarte.example.com/pairing&quot; ).","ref":"virtual_device_pool.html#pairing_url","title":"virtual_device_pool - pairing_url","type":"extras"},{"doc":"An object used to configure the target devices. The object must contain these keys: realm : the realm name (required, string) jwt : a JWT with the correct claims to access the target Astarte Pairing API instance. (required, string) This is an example of a realms object: { realm : &quot;test&quot; , jwt : &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MTIyODA4MjIsImFfcGEiOlsiLio6Oi4qIl19.RjqQGV3-ZNbqJ-wj77Sw41CfsWHhlLf9hBZ1Ni-2TQNeKwdpWlmClA1yrtRv41dtVojWjGPLdPMeC7R7yx46VgJlnJXrNE1ffxflAtls5kE3cMF8h6scqbS4Hy7oP_G2g7XS1c9HCwwkiSRzqu6pUY0XgtI0ss35OhvrpkNn0UC4sGS8uAxQauATbfzBdIvkiWPqF-CUrT23sHISlfEv6Y_cnciszJsGTGhVlG1M2hqYHITgnFOivxCgLPQUpqI0GCjkPbfJp9eBClDXJdvIimzRQ74Hv0arBOC6OrCLvztMAwQaxBm47w9sCjkP-aCMN2JqBpmimzFEU8ulXVjxQcgfnAIWrL1cMo4DOhwPvRmyy6Zc9ahRzQdpYvbzbTTfMkPU6u3m-u9CL5JXI8B1l_RriambWsbUeMsOR0WZG9zC98YUwar9bA1o6S7w-3DzxuXDZ4yEe_VdEO8QHb9G_5S1nYXClFXoeL2tRk4Ib9g2HzewC3Zt7pQCX3ksukaPwsxauivQ6m3C_j6LEPiPR4FG2-rJyWFrnAmltYlYs0z7rP0WQjicNIpIRZkB2ovi8gw-PHXFbVlmFfoTx7yl2wWXxLIFDoDieZGdbYcciOERZZ_JzeF7XEWnJvUPmIGhwa5W-UEhAPHXrYjuvHeWTC-FIV5yvjiiSKYjA-DiZSU&quot; }","ref":"virtual_device_pool.html#realms","title":"virtual_device_pool - realms","type":"extras"},{"doc":"The interfaces supported by the target devices. Note that this should be an array of objects, the whole interface definition in must be present for every interface. Right now only datastream interfaces are supported. This is an example of an interfaces array: [ { interface_name : &quot;org.astarte-platform.genericsensors.Values&quot; , version_major : 1 , version_minor : 0 , type : &quot;datastream&quot; , ownership : &quot;device&quot; , description : &quot;Generic sensors sampled data.&quot; , mappings : [ { endpoint : &quot;/%{sensor_id}/value&quot; , type : &quot;double&quot; , explicit_timestamp : true , description : &quot;Sampled real value.&quot; , doc : &quot;Datastream of sampled real values.&quot; } ] } ] Accepted Input Messages When receiving a message, the virtual_device_pool block expects a key with this format: realm / device_id / interface_name / path So, for example, an incoming message with key test/EA8lpOrkR8OJ-bp9dSVYQA/org.astarte-platform.genericsensors.Values/mysensor/value will produce a message sent from a device in the test realm with Device ID EA8lpOrkR8OJ-bp9dSVYQA on the org.astarte-platform.genericsensors.Values interface with /mysensor/value path. If you're using a static virtual_device_pool , the Device ID must be present in the list of target devices. If you're using a dynamic virtual_device_pool , the device will be registered if needed. data (and its type ) must be compatible with the type declared in the mapping of the interface, so if an interface expects a double value but a string is received, the message will be discarded. If the interface supports an explicit_timestamp , the message timestamp is used as explicit timestamp. Examples","ref":"virtual_device_pool.html#interfaces","title":"virtual_device_pool - interfaces","type":"extras"},{"doc":"[ ... ] | virtual_device_pool . pairing_url ( &quot;https://astarte.example.com/pairing&quot; ) . target_devices ( [ { realm : &quot;test&quot; , device_id : &quot;EA8lpOrkR8OJ-bp9dSVYQA&quot; , credentials_secret : &quot;N0hUYzmGzpK2SdN8FLoFtw==&quot; , interfaces : [ { interface_name : &quot;org.astarte-platform.genericsensors.Values&quot; , version_major : 1 , version_minor : 0 , type : &quot;datastream&quot; , ownership : &quot;device&quot; , description : &quot;Generic sensors sampled data.&quot; , mappings : [ { endpoint : &quot;/%{sensor_id}/value&quot; , type : &quot;double&quot; , explicit_timestamp : true , description : &quot;Sampled real value.&quot; , doc : &quot;Datastream of sampled real values.&quot; } ] } ] } ] )","ref":"virtual_device_pool.html#static-devices","title":"virtual_device_pool - Static devices","type":"extras"},{"doc":"| virtual_device_pool . pairing_url ( &quot;https://astarte.example.com/pairing&quot; ) . realms ( [ { realm : &quot;test&quot; , jwt : &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MTIyODA4MjIsImFfcGEiOlsiLio6Oi4qIl19.RjqQGV3-ZNbqJ-wj77Sw41CfsWHhlLf9hBZ1Ni-2TQNeKwdpWlmClA1yrtRv41dtVojWjGPLdPMeC7R7yx46VgJlnJXrNE1ffxflAtls5kE3cMF8h6scqbS4Hy7oP_G2g7XS1c9HCwwkiSRzqu6pUY0XgtI0ss35OhvrpkNn0UC4sGS8uAxQauATbfzBdIvkiWPqF-CUrT23sHISlfEv6Y_cnciszJsGTGhVlG1M2hqYHITgnFOivxCgLPQUpqI0GCjkPbfJp9eBClDXJdvIimzRQ74Hv0arBOC6OrCLvztMAwQaxBm47w9sCjkP-aCMN2JqBpmimzFEU8ulXVjxQcgfnAIWrL1cMo4DOhwPvRmyy6Zc9ahRzQdpYvbzbTTfMkPU6u3m-u9CL5JXI8B1l_RriambWsbUeMsOR0WZG9zC98YUwar9bA1o6S7w-3DzxuXDZ4yEe_VdEO8QHb9G_5S1nYXClFXoeL2tRk4Ib9g2HzewC3Zt7pQCX3ksukaPwsxauivQ6m3C_j6LEPiPR4FG2-rJyWFrnAmltYlYs0z7rP0WQjicNIpIRZkB2ovi8gw-PHXFbVlmFfoTx7yl2wWXxLIFDoDieZGdbYcciOERZZ_JzeF7XEWnJvUPmIGhwa5W-UEhAPHXrYjuvHeWTC-FIV5yvjiiSKYjA-DiZSU&quot; } ] ) . interfaces ( [ { interface_name : &quot;org.astarte-platform.genericsensors.Values&quot; , version_major : 1 , version_minor : 0 , type : &quot;datastream&quot; , ownership : &quot;device&quot; , description : &quot;Generic sensors sampled data.&quot; , mappings : [ { endpoint : &quot;/%{sensor_id}/value&quot; , type : &quot;double&quot; , explicit_timestamp : true , description : &quot;Sampled real value.&quot; , doc : &quot;Datastream of sampled real values.&quot; } ] } ] )","ref":"virtual_device_pool.html#dynamic-devices","title":"virtual_device_pool - Dynamic devices","type":"extras"}]